MODULE Miscellaneous; (*JG 20.5.94 / NW 22.2.88*)

  IMPORT Kernel, Display, Pictures, Files, Viewers, MenuViewers, Fonts, Texts, TextFrames, Oberon, Centronics, V24;
  
  CONST  TAB =  9X; CR = 0DX; LF = 0AX; BitmapId = 39X; 
        StandardMenu = "System.Close System.Copy System.Grow Edit.Search Edit.Store";
        xOn = 11X; xOff = 13X;
  
  VAR W: Texts.Writer;
  		port: INTEGER;

    PROCEDURE Count (VAR name: ARRAY OF CHAR; VAR nofLines: LONGINT; T: Texts.Text);
    VAR R: Texts.Reader; source: Texts.Text; i: LONGINT; ch: CHAR;
    BEGIN
    Texts.WriteString(W, name);
    Texts.Append(T, W.buf);
    NEW(source); Texts.Open(source, name);
    Texts.WriteString(W," counting");
    Texts.Append(T, W.buf);
    Texts.OpenReader(R, source, 0);
    nofLines := 0; i := 0;
    WHILE i < source.len DO
      Texts.Read(R, ch); INC(i);
      IF ch = CR THEN
        LOOP
          Texts.Read(R, ch); INC(i);
          IF ch # CR THEN EXIT END
        END;
        INC(nofLines)
      END
    END;
    Texts.Write(W, " "); Texts.WriteInt(W, nofLines, 1);
    Texts.WriteLn(W);
    Texts.Append(T, W.buf)
    END Count;
  
  PROCEDURE CountLines*;
    VAR par: Oberon.ParList;
      S: Texts.Scanner;
      T: Texts.Text;
      V: Viewers.Viewer;
      nofLines, totalLines, beg, end, time: LONGINT;
            X, Y: INTEGER;
  BEGIN
    T := TextFrames.Text("");
        Oberon.AllocateSystemViewer(Oberon.Par.frame.X, X, Y);
    V := MenuViewers.New(
          TextFrames.NewMenu("Miscellaneous.CountLines", StandardMenu),
          TextFrames.NewText(T, 0),
          TextFrames.menuH,
          X, Y);
    totalLines := 0;
    par := Oberon.Par;
    Texts.OpenScanner(S, par.text, par.pos); Texts.Scan(S);
    WHILE S.class = Texts.Name DO
          Count(S.s, nofLines, T); totalLines := totalLines + nofLines; Texts.Scan(S)
        END;
        IF (S.class = Texts.Char) & (S.c = "^") THEN Oberon.GetSelection(T, beg, end, time);
          IF time >= 0 THEN Texts.OpenScanner(S, T, beg); Texts.Scan(S);
            IF S.class = Texts.Name THEN
              Count(S.s, nofLines, T); totalLines := totalLines + nofLines
            END
          END
        END;
    Texts.WriteInt(W, totalLines, 1);
    Texts.WriteLn(W);
    Texts.Append(T, W.buf)
  END CountLines;

    PROCEDURE GetSize (VAR name: ARRAY OF CHAR; VAR varSize: LONGINT;
        VAR constSize: INTEGER; VAR codeSize: LONGINT; T: Texts.Text);
    VAR f: Files.File; R: Files.Rider;
    BEGIN
    Texts.WriteString(W, name);
    Texts.Append(T, W.buf);
    f := Files.Old(name);
    IF f # NIL THEN
      Files.Set(R, f, 17);
      Files.ReadBytes(R, varSize, 4);  Files.ReadInt(R, constSize); Files.ReadLInt(R, codeSize);
      Texts.WriteString(W, " var "); Texts.WriteInt(W, varSize, 1);
      Texts.WriteString(W, " const "); Texts.WriteInt(W, constSize, 1);
      Texts.WriteString(W, " code "); Texts.WriteInt(W, codeSize, 1)
    ELSE Texts.WriteString(W, " not found")
    END;
    Texts.WriteLn(W);
    Texts.Append(T, W.buf)
    END GetSize;

  PROCEDURE GetObjSize*;
    VAR par: Oberon.ParList;
      S: Texts.Scanner;
      T: Texts.Text;
      V: Viewers.Viewer;
      constSize: INTEGER;
      codeSize: LONGINT;
            varSize, totalConstSize, totalVarSize, totalCodeSize: LONGINT;
            beg, end, time: LONGINT;
      X, Y: INTEGER;
  BEGIN
    T := TextFrames.Text("");
        Oberon.AllocateSystemViewer(Oberon.Par.frame.X, X, Y);
    V := MenuViewers.New(
          TextFrames.NewMenu("Miscellaneous.GetObjSize", StandardMenu),
          TextFrames.NewText(T, 0),
          TextFrames.menuH,
          X, Y);
    totalVarSize := 0; totalConstSize := 0; totalCodeSize := 0;
    par := Oberon.Par;
    Texts.OpenScanner(S, par.text, par.pos); Texts.Scan(S);
    WHILE S.class = Texts.Name DO
          GetSize(S.s, varSize, constSize, codeSize, T);
          totalVarSize := totalVarSize + varSize;
          totalConstSize := totalConstSize + constSize;
          totalCodeSize := totalCodeSize + codeSize;
          Texts.Scan(S)
        END;
        IF (S.class = Texts.Char) & (S.c = "^") THEN Oberon.GetSelection(T, beg, end, time);
          IF time >= 0 THEN Texts.OpenScanner(S, T, beg); Texts.Scan(S);
            IF S.class = Texts.Name THEN
              GetSize(S.s, varSize, constSize, codeSize, T);
              totalVarSize := totalVarSize + varSize;
              totalConstSize := totalConstSize + constSize;
              totalCodeSize := totalCodeSize + codeSize
            END
          END
    END;
    Texts.WriteString(W, " var "); Texts.WriteInt(W, totalVarSize, 1);
    Texts.WriteString(W, " const "); Texts.WriteInt(W, totalConstSize, 1);
    Texts.WriteString(W, " code "); Texts.WriteInt(W, totalCodeSize, 1);
    Texts.WriteLn(W);
    Texts.WriteInt(W, totalVarSize + totalConstSize + totalCodeSize, 1);
    Texts.WriteLn(W);
    Texts.Append(T, W.buf)
  END GetObjSize;

  PROCEDURE Snapshot*;
  VAR x, y, col, col1: INTEGER; help: LONGINT;
      f: Files.File; S: Texts.Scanner;
      P: Pictures.Picture;
  
    PROCEDURE GetPix(x, y: INTEGER; VAR col: INTEGER);
    BEGIN
    	Kernel.Regs.AX := 0D00H;
    	Kernel.Regs.CX := x;
    	Kernel.Regs.DX := y;
    	Kernel.INT(Kernel.Regs, 10H);
    	col := Kernel.Regs.AX MOD 100H;
    END GetPix;

  BEGIN
    Texts.WriteString(W, "Miscellaneous.Snapshot ");
    Texts.Append(Oberon.Log, W.buf);
    IF Display.Width > 640 THEN
      Texts.WriteString(W, "screen size not supported");
    ELSE
      Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
      IF S.class # Texts.Name THEN Texts.WriteString(W, "missing name")
      ELSE
        Texts.WriteString(W, "creating "); Texts.WriteString(W, S.s);
        Texts.Append(Oberon.Log, W.buf);
        NEW(P);
        Pictures.Create(P, Display.Width, Display.Height+1, 8);
        f := Files.New(S.s);
        x := 0; y := Display.Height; 
        WHILE  y > 0 DO
          WHILE Display.Width > x DO
            GetPix(x, y, col); Pictures.Dot(P, col, x, Display.Height +1 - y, 0); INC(x)
          END;     
          DEC(y); x := 0;
        END;
        Pictures.Store(P, f, 0, help);
        Files.Register(f)
      END
    END;
    Texts.WriteLn(W);
    Texts.Append(Oberon.Log, W.buf)
  END Snapshot;

  PROCEDURE MakeAscii*;
    VAR  R: Texts.Reader; S: Texts.Scanner; T: Texts.Text;
      g: Files.File; Wg: Files.Rider; ch: CHAR; name: ARRAY 32 OF CHAR;
  BEGIN
    Texts.WriteString(W, "Miscellaneous.MakeAscii"); Texts.WriteLn(W);
    Texts.Append(Oberon.Log, W.buf);
    Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
    WHILE S.class = Texts.Name DO
      COPY(S.s, name); Texts.Scan(S);
      IF (S.class = Texts.Char) & (S.c = "=") THEN Texts.Scan(S);
        IF (S.class = Texts.Char) & (S.c = ">") THEN Texts.Scan(S);
          IF S.class = Texts.Name THEN
            Texts.WriteString(W, name); Texts.WriteString(W," => ");
                    Texts.WriteString(W, S.s); Texts.Append(Oberon.Log, W.buf);
                    NEW(T); Texts.Open(T, name);
                    g := Files.New(S.s); Files.Set(Wg, g, 0);
                    Texts.OpenReader(R, T, 0); Texts.Read(R, ch);
                    WHILE ~R.eot DO
                    IF (R.lib IS Fonts.Font) &
                    ((ch >= " ") & (ch < 7FX) OR (ch = TAB) OR (ch = CR)) THEN Files.Write(Wg, ch)
                          END;
                    Texts.Read(R, ch)
                    END;
                    Files.Register(g);
                    Texts.WriteLn(W);
                    Texts.Append(Oberon.Log, W.buf)
          END
        END
      END;
      Texts.Scan(S)
    END;
  END MakeAscii;

    PROCEDURE DOSRead (VAR R: Files.Rider; VAR ch: CHAR);
    BEGIN Files.Read(R, ch);
       IF ch >= 80X THEN
         IF ch = 8EX THEN ch := 80X
           ELSIF ch = 99X THEN ch := 81X
           ELSIF ch = 9AX THEN ch := 82X
           ELSIF ch = 84X THEN ch := 83X
           ELSIF ch = 94X THEN ch := 84X
           ELSIF ch = 81X THEN ch := 85X
         END
      END
    END DOSRead;

  PROCEDURE MakeOberonText*;
    VAR S: Texts.Scanner; T: Texts.Text; f, g: Files.File; Rf, Wg: Files.Rider;
         ch: CHAR; name: ARRAY 32 OF CHAR;
  BEGIN
        Texts.WriteString(W, "Miscellaneous.MakeOberonText"); Texts.WriteLn(W);
        Texts.Append(Oberon.Log, W.buf);
    Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
    WHILE S.class = Texts.Name DO
      COPY(S.s, name); Texts.Scan(S);
      IF (S.class = Texts.Char) & (S.c = "=") THEN Texts.Scan(S);
        IF (S.class = Texts.Char) & (S.c = ">") THEN Texts.Scan(S);
          IF S.class = Texts.Name THEN
            Texts.WriteString(W, name); Texts.WriteString(W," => ");
                    Texts.WriteString(W, S.s); Texts.Append(Oberon.Log, W.buf);
                    f := Files.Old(name); Files.Set(Rf, f, 0);
                    g := Files.New(S.s); Files.Set(Wg, g, 0);
                    DOSRead(Rf, ch);
                    WHILE ~Rf.eof DO
                          IF ch # LF THEN Files.Write(Wg, ch) END;
                    DOSRead(Rf, ch)
                    END;
                    Files.Register(g);
                    Texts.WriteLn(W);
                    Texts.Append(Oberon.Log, W.buf)
          END
        END
      END;
      Texts.Scan(S)
    END;
  END MakeOberonText;

    PROCEDURE OberonRead (VAR R: Texts.Reader; VAR ch: CHAR);
    BEGIN Texts.Read(R, ch);
       IF ch >= 80X THEN
         IF ch = 80X THEN ch := 8EX
           ELSIF ch = 81X THEN ch := 99X
           ELSIF ch = 82X THEN ch := 9AX
           ELSIF ch = 83X THEN ch := 84X
           ELSIF ch = 84X THEN ch := 94X
           ELSIF ch = 85X THEN ch := 81X
         END
      END
    END OberonRead;

    PROCEDURE ReadWord (VAR R: Texts.Reader; VAR len: INTEGER; VAR buf: ARRAY OF CHAR);
    BEGIN len := 0;
      WHILE buf[len] > " " DO INC(len); OberonRead(R, buf[len]) END
    END ReadWord;

  PROCEDURE MakeDOSText*;
    VAR  R: Texts.Reader; S: Texts.Scanner; T: Texts.Text;
          g: Files.File; Wg: Files.Rider; termCh: CHAR; pos, len, i: INTEGER;
          name: ARRAY 32 OF CHAR; buf: ARRAY 128 OF CHAR;
  BEGIN
        Texts.WriteString(W, "Miscellaneous.MakeDOSText"); Texts.WriteLn(W);
        Texts.Append(Oberon.Log, W.buf);
    Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
    WHILE S.class = Texts.Name DO
      COPY(S.s, name); Texts.Scan(S);
      IF (S.class = Texts.Char) & (S.c = "=") THEN Texts.Scan(S);
        IF (S.class = Texts.Char) & (S.c = ">") THEN Texts.Scan(S);
          IF S.class = Texts.Name THEN
            Texts.WriteString(W, name); Texts.WriteString(W," => ");
                    Texts.WriteString(W, S.s); Texts.Append(Oberon.Log, W.buf);
                    NEW(T); Texts.Open(T, name);
                    g := Files.New(S.s); Files.Set(Wg, g, 0);
                    Texts.OpenReader(R, T, 0); termCh := 0X; pos := 0;
                      OberonRead(R, buf[0]);
                  WHILE ~R.eot DO ReadWord(R, len, buf);
                      IF (termCh = CR) OR (termCh # 0X) & (pos + 1 + len > 78) THEN
                        Files.Write(Wg, CR); Files.Write(Wg, LF); termCh := 0X; pos := 0
                      END;
                      IF termCh # 0X THEN Files.Write(Wg, termCh); INC(pos) END;
                      i := 0;
                      WHILE i # len DO Files.Write(Wg, buf[i]); INC(i) END;
                      pos := pos + len; termCh := buf[i];
                      OberonRead(R, buf[0])
                  END;
                    IF (termCh = CR) OR (termCh # 0X) & (pos + 1 > 78) THEN
                      Files.Write(Wg, CR); Files.Write(Wg, LF); termCh := 0X; pos := 0
                    END;
                    IF termCh # 0X THEN Files.Write(Wg, termCh); INC(pos) END;
                Files.Register(g);
                Texts.WriteLn(W);
                Texts.Append(Oberon.Log, W.buf)
                  END
        END
      END;
      Texts.Scan(S)
    END;
  END MakeDOSText;

    PROCEDURE Do*; (*uh 18.1.93*)
    VAR S: Texts.Scanner; text: Texts.Text; vwr: Viewers.Viewer;
      pos: LONGINT; par: Oberon.ParList; X, Y, res: INTEGER;
      frame: Display.Frame;
    
    PROCEDURE NextLine(text: Texts.Text; pos: LONGINT): LONGINT;
      VAR R: Texts.Reader; ch: CHAR;
    BEGIN
      IF pos < text.len THEN 
        Texts.OpenReader(R, text, pos); Texts.Read(R, ch);
        WHILE ~ R.eot & (ch # 0DX) DO Texts.Read(R, ch) END;
        IF R.eot THEN RETURN -1 ELSE RETURN Texts.Pos(R) END
      ELSE RETURN -1
      END
    END NextLine;
  
  BEGIN
    vwr := Oberon.Par.vwr;
    frame := Oberon.Par.frame;
    text := Oberon.Par.text;
    Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
    NEW(par);
    WHILE S.class = Texts.Name DO
      par.vwr := vwr; par.frame := frame; par.text := text; 
      par.pos := Texts.Pos(S) - 1; pos := NextLine(text, par.pos); 
      Oberon.Call(S.s, par, FALSE, res);
      IF pos > 0 THEN Texts.OpenScanner(S, text, pos); Texts.Scan(S)
      ELSE S.class :=Texts.Inval
      END
    END
  END Do;

	PROCEDURE V24Write(ch: CHAR);
	VAR dr: CHAR;
	BEGIN
		IF V24.Available(port) > 0 THEN 
			V24.Receive(port, dr);
			IF dr = xOff THEN
				REPEAT IF V24.Available(port) > 0 THEN V24.Receive(port, dr) END UNTIL dr = xOn; 
			END
		END;
		V24.Send(port, ch)
	END V24Write;
	
	PROCEDURE SendFiles*;
	VAR S: Texts.Scanner; Port, fname: ARRAY 32 OF CHAR;
			f: Files.File; R: Files.Rider; ch: CHAR;
	BEGIN
		Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
		IF (S.class = Texts.Name) OR (S.class = Texts.String) THEN
			COPY(S.s, Port); Texts.Scan(S);
			IF (S.class = Texts.Name) OR (S.class = Texts.String) THEN
				COPY(S.s, fname);
				IF (Port = "COM1") OR (Port = "COM2") THEN
					IF Port = "COM1" THEN port := V24.COM1 ELSE port := V24.COM2 END;
					V24.Start(port, V24.WL8, V24.STOP1, V24.NOPAR, V24.BPS9600);
					f := Files.Old(fname);
					IF f # NIL THEN 
						Files.Set(R, f, 0); Files.Read(R, ch);
						WHILE ch # "%" DO Files.Read(R, ch) END;
						WHILE ~R.eof DO V24Write(ch); Files.Read(R, ch) END; 
						V24Write(4X);
						REPEAT IF V24.Available(port) > 0 THEN V24.Receive(port, ch) END UNTIL ch = 4X;
						V24.Stop(port);
						Files.Close(f);
					ELSE Texts.WriteString(W, "file not found"); Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf) END;
				ELSIF (Port = "LPT1") OR (Port = "LPT2") OR (Port = "LPT3") THEN
					IF Port = "LPT1" THEN port := Centronics.LPT1 
					ELSIF Port = "LPT2" THEN port := Centronics.LPT2
					ELSE port := Centronics.LPT3 END;
					Centronics.Start(port);
					f := Files.Old(fname);
					IF f # NIL THEN 
						Files.Set(R, f, 0); Files.Read(R, ch);
						WHILE ch # "%" DO Files.Read(R, ch) END;
						WHILE ~R.eof DO Centronics.Send(port, ch); Files.Read(R, ch) END; 
						Centronics.Send(port, 4X);
						Files.Close(f)
					ELSE Texts.WriteString(W, "file not found"); Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf) END;
				ELSE Texts.WriteString(W, "not a valid port"); Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf) END;
			ELSE Texts.WriteString(W, "no name specified"); Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf) END
		ELSE Texts.WriteString(W, "no port specified"); Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf) END
	END SendFiles;

BEGIN Texts.OpenWriter(W)
END Miscellaneous.

