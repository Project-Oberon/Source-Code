MODULE Diskette; (*JG Ceres-2 version/14.2.90*)

	IMPORT SYSTEM, Kernel, Files;

	CONST 

        Oberon* = 0E9X;
        MSDOS* = 0F9X;

		(*WD1002-05 registers*)
		DRdata       = 0FFFF8000H;  (*R/W data*)
		DRerrst      = 0FFFF8004H;  (*R error status*)
		DRprecomp    = 0FFFF8004H;  (*W write precomp*)
		DRseccnt     = 0FFFF8008H;  (*R/W sector count*)
		DRsecno      = 0FFFF800CH;  (*R/W sector number*)
		DRcyllo      = 0FFFF8010H;  (*R/W cylinder low byte*)
		DRcylhi      = 0FFFF8014H;  (*R/W cylinder high byte*)
		DRsdh        = 0FFFF8018H;  (*R/W side/drive/head*)
		DRstatus     = 0FFFF801CH;  (*R status*)
		DRcommand    = 0FFFF801CH;  (*W command*)

		(*bits in DRstatus,  bits in DRerrst*)
		DSbusy       = 7;    DEbadblk     = 7;  (*bad block mark*)
		DSready      = 6;    DEuncorr     = 6;  (*unreadable sector*)
		DSwrfault    = 5;    DEcrcID      = 5;  (*unreadable ID field*)
		DSseekcompl  = 4;    DEnoID       = 4;  (*specified ID not found*)
		DSdatareq    = 3;    DEaborted    = 2;  (*command aborted*)
		DScorrected  = 2;    DETR000      = 1;  (*track 0 not reached*)
		DSerror      = 0;    DEnoDAM      = 0;  (*data adr mark not found*)

		(*WD1002-05 commands*)
		DCread       = 20X;
		DCwrite      = 30X;

		(*FD command and drive spex*)
		restore = 13X;
		format = 50X;
		surfaces = 2;
		tracks = 80;  (*per surface*)
		sectors = 9;   (*per track*)
		sectorsize = 512;
		steprate = 3;

	 	 (* MS-DOS format 0F9H for 3.5 inch diskettes:
 
							parameters                 sector allocation

				surfaces                  2          0        descriptor
				tracks/surface      80          1..3     FAT
				sectors/track          9          4..6     FAT copy
				bytes/sector       512          7..13    directory
				sectors/cluster      2         14..1439  file data
				directory entries  112*)

	TYPE 

		FileDesc = RECORD (*image of dir entry*)
			name: ARRAY 22 OF CHAR;
			time, date: INTEGER;
		    head: INTEGER;
			size: LONGINT
		END;

		File = POINTER TO FileHandle;

		FileHandle = RECORD
			prev, next: File;
			file: FileDesc
		END;

        EntryHandler* = PROCEDURE (name: ARRAY OF CHAR; date, time, size: LONGINT);

	VAR

        SecSize*: INTEGER;

        res*: INTEGER;
        err*: SHORTINT;
        sect*: LONGINT; busy*: BOOLEAN;
		dir: File; trailer: FileDesc;
		d, t: LONGINT;
        usedF, usedC: INTEGER;
 	   FAT: ARRAY 720 OF INTEGER;

(*driver*)

	PROCEDURE wait;
	BEGIN
		REPEAT UNTIL ~SYSTEM.BIT(DRstatus, DSbusy)
	END wait;

	PROCEDURE SetPars (sec, cnt: INTEGER; cmd: CHAR);
		VAR secno, track, cyl, surf: INTEGER;
	BEGIN
		secno := sec MOD sectors + 1;
		track := sec DIV sectors;
		cyl  := track DIV surfaces;
		surf := track MOD surfaces;
		SYSTEM.PUT(DRsecno, secno); SYSTEM.PUT(DRcyllo, cyl MOD 256);
		SYSTEM.PUT(DRcylhi, cyl DIV 256); SYSTEM.PUT(DRsdh, surf + 38H);
		SYSTEM.PUT(DRseccnt, cnt); SYSTEM.PUT(DRcommand, cmd)
	END SetPars;

   PROCEDURE Reset*;
   END Reset;

	PROCEDURE GetSector* (sec: INTEGER; VAR buf: ARRAY OF SYSTEM.BYTE; off: INTEGER);
		VAR retry, I, i: INTEGER;
	BEGIN retry := 3; busy := TRUE;
		LOOP
			SetPars(sec, 1, DCread); wait;
			i := off; I := off + 512;
			REPEAT SYSTEM.GET(DRdata, buf[i]); INC(i) UNTIL i = I;
			IF ~SYSTEM.BIT(DRstatus, DSerror) THEN busy := FALSE; EXIT END ;
			SYSTEM.GET(DRerrst, err); sect := sec; DEC(retry);
			IF retry = 0 THEN busy := FALSE; HALT(28) END
		END
	END GetSector;

	PROCEDURE PutSector* (sec: INTEGER; VAR buf: ARRAY OF SYSTEM.BYTE; off: INTEGER);
		VAR retry, I, i: INTEGER;
	BEGIN retry := 3; busy := TRUE;
		LOOP
			SetPars(sec, 1, DCwrite);
			i := off; I := off + 512;
			REPEAT SYSTEM.PUT(DRdata, buf[i]); INC(i) UNTIL i = I;
			wait;
			IF ~SYSTEM.BIT(DRstatus, DSerror) THEN busy := FALSE; EXIT END ;
			SYSTEM.GET(DRerrst, err); sect := sec; DEC(retry);
			IF retry = 0 THEN busy := FALSE; HALT(28) END
		END
	END PutSector;

	PROCEDURE Format*;
		VAR track, i: INTEGER;
	BEGIN track := 0;
		REPEAT i := 0;
			SetPars(track*sectors, sectors, format);
			REPEAT
				SYSTEM.PUT(DRdata, 0); SYSTEM.PUT(DRdata, i MOD sectors + 1); INC(i, 2)
			UNTIL i = 2 * sectors;
			REPEAT SYSTEM.PUT(DRdata, 0); INC(i)
			UNTIL i = sectorsize;
			wait; INC(track)
		UNTIL track = surfaces * tracks
	END Format;

(*directory*)

	PROCEDURE InitDir*;
		VAR i: INTEGER;
	BEGIN
		NEW(dir); dir.file.name[0] := 0FFX;
		dir.file.name[11] := 8X; (*def as vol label*)
		dir.next := dir; dir.prev := dir;
		usedF := 1; usedC := 7;
		FAT[0] := -1; FAT[1] := -1;
		i := 2;
		REPEAT FAT[i] := 0; FAT[i+1] := 0; i := i+2 UNTIL i = 720
	END InitDir;

	PROCEDURE Clusters (size: LONGINT): INTEGER;
	BEGIN RETURN SHORT((size + 1023) DIV 1024)
	END Clusters;

	PROCEDURE findFile (name: ARRAY OF CHAR; VAR f: File);
	BEGIN f := dir.next;
		WHILE f.file.name < name DO f := f.next END
	END findFile;

	PROCEDURE ReadDir*;
		VAR f, g: File; n: LONGINT; s, i, j, n0, n1: INTEGER;
			buf: ARRAY 1536 OF CHAR;
			dBuf: ARRAY 16 OF FileDesc;
	BEGIN
        (*read boot sector*)
		GetSector(0, buf, 0);
		IF (buf[21] # 0F9X) & (buf[21] # 0E9X) THEN HALT(54) END;
		GetSector(7, dBuf, 0); (*read volume label*)
		NEW(f); f.file := dBuf[0];
		IF f.file.name[11] # 8X THEN HALT(54) END; (*not vol label*)
        IF (f.file.name[0] < 0E5X) & (f.file.name[0] # 0X) THEN HALT(55) END; (*not Oberon format*)
        f.file.name[0] := 0FFX;
        (*read dir*)
		f.prev := f; f.next := f; dir := f;
		usedF := 1; usedC := 7;
		s := 7; j := 1;
        LOOP
		    IF (dBuf[j].name[0] = 0X) OR (dBuf[j].name[0] = 0E5X) THEN EXIT END;
			NEW(f); f.file := dBuf[j];
			findFile(f.file.name, g);
			f.next := g; g.prev.next := f; f.prev := g.prev; g.prev := f;
			INC(usedF); usedC := usedC + Clusters(f.file.size);
			INC(j);
			IF j = 16 THEN INC(s); j := 0;
                IF s = 14 THEN EXIT END;
                GetSector(s, dBuf, 0)
            END
		END;
		(*read FAT*)
		GetSector(1, buf, 0);
		GetSector(2, buf, 512);
		GetSector(3, buf, 1024);
		FAT[0] := -1; FAT[1] := -1;
		i := 2; j := 3;
		REPEAT
			n :=     ORD(buf[j+2]); n := n*256;
			n := n + ORD(buf[j+1]); n := n*256;
			n := n + ORD(buf[j]);
			n0 := SHORT(n MOD 4096); n1 := SHORT(n DIV 4096);
			IF n0 > 2047 THEN n0 := n0 - 4096 END;
			IF n1 > 2047 THEN n1 := n1 - 4096 END;
			FAT[i] := n0; FAT[i+1] := n1;
			i := i + 2; j := j + 3
		UNTIL i = 720
	END ReadDir;

	PROCEDURE WriteDir*;
		VAR f: File; n: LONGINT; s, i, j, n0, n1: INTEGER;
			buf: ARRAY 1536 OF CHAR;
			dBuf: ARRAY 16 OF FileDesc;
	BEGIN
        (*write boot sector*)
        buf[21] := 0F9X;
		PutSector(0, buf, 0);
		(*write FAT*)
		buf[0] := 0F9X;
		buf[1] := 0FFX;
		buf[2] := 0FFX;
	    i := 2; j := 3;
		REPEAT
			n0 := FAT[i]; n1 := FAT[i+1];
			IF n0 < 0 THEN n0 := n0 + 4096 END;
			IF n1 < 0 THEN n1 := n1 + 4096 END;
			n := n1; n := n*4096 + n0;
			buf[j] := CHR(SHORT(n MOD 256)); n := n DIV 256;
			buf[j+1] := CHR(SHORT(n MOD 256)); n := n DIV 256;
			buf[j+2] := CHR(SHORT(n));
			i := i + 2; j := j + 3
		UNTIL i = 720;
		PutSector(1, buf, 0);
		PutSector(2, buf, 512);
		PutSector(3, buf, 1024);
		(*write dir*)
		s := 7; j := 0; f := dir;
		REPEAT
		    dBuf[j] := f.file; INC(j);
			IF j = 16 THEN PutSector(s, dBuf, 0); INC(s); j := 0 END;
			f := f.next
		UNTIL f = dir;
        IF s # 14 THEN
		    dBuf[j] := trailer;
		    PutSector(s, dBuf, 0)
        END
	END WriteDir;

    PROCEDURE GetData* (VAR date, time: LONGINT; VAR nofFiles, nofClusters: INTEGER);
    BEGIN date := dir.file.date; time := LONG(dir.file.time)*2; nofFiles := usedF; nofClusters := usedC
    END GetData;

    PROCEDURE Enumerate* (proc: EntryHandler);
        VAR f: File;
    BEGIN f := dir.next;
        WHILE f # dir DO proc(f.file.name, f.file.date, LONG(f.file.time)*2, f.file.size); f := f.next END
    END Enumerate;

	PROCEDURE readFile (f: File; g: Files.File);
		VAR Wg: Files.Rider;
			size: LONGINT; i: INTEGER;
			buf: ARRAY 1024 OF CHAR;
	BEGIN Files.Set(Wg, g, 0);
		size := f.file.size;
		IF size # 0 THEN
			i := f.file.head;
			LOOP
				GetSector(10 + 2*i, buf, 0);
				GetSector(11 + 2*i, buf, 512);
				IF FAT[i] = -1 THEN EXIT END;
				Files.WriteBytes(Wg, buf, 1024);
				size := size - 1024; i := FAT[i]
			END;
			Files.WriteBytes(Wg, buf, SHORT(size))
		END
	END readFile;

	PROCEDURE deleteFile (f: File);
		VAR i, j: INTEGER;
	BEGIN
		f.prev.next := f.next; f.next.prev := f.prev;
		i := f.file.head;
		REPEAT j := FAT[i]; FAT[i] := 0; i := j UNTIL i = -1
	END deleteFile;

	PROCEDURE addFile (f: Files.File; g, h: File);
		VAR Rf: Files.Rider;
			need, i, j: INTEGER;
			buf: ARRAY 1024 OF CHAR;
	BEGIN Files.Set(Rf, f, 0);
		need := Clusters(g.file.size);
		IF need # 0 THEN
			j := 2;
			WHILE FAT[j] # 0 DO INC(j) END;
			g.file.head := j;
			LOOP i := j;
				Files.ReadBytes(Rf, buf, 1024);
				PutSector(10 + 2*i, buf, 0);
				PutSector(11 + 2*i, buf, 512);
				DEC(need);
				IF need = 0 THEN EXIT END;
				INC(j);
				WHILE FAT[j] # 0 DO INC(j) END;
				FAT[i] := j
			END;
			FAT[i] := -1
		END;
		g.next := h; h.prev.next := g; g.prev := h.prev; h.prev := g
	END addFile;

	PROCEDURE ReadAll*;
		VAR f: File; g: Files.File;
	BEGIN
		ReadDir;
		f := dir.next;
		WHILE f # dir DO
			g := Files.New(f.file.name); readFile(f, g); Files.Register(g); f := f.next
		END
	END ReadAll;

	PROCEDURE ReadFile* (name: ARRAY OF CHAR);
		VAR f: File; g: Files.File;
	BEGIN
		findFile(name, f);
		IF f.file.name = name THEN
			g := Files.New(name); readFile(f, g); Files.Register(g); res := 0
		ELSE res := 1
		END
	END ReadFile;

	PROCEDURE WriteFile* (name: ARRAY OF CHAR);
		VAR f: Files.File; g, h: File; d, t: LONGINT; needC: INTEGER;
	BEGIN res := 0;
		NEW(g); g.file.name[11] := 0X; (*attributes*)
		COPY(name, g.file.name);
		f := Files.Old(name);
		IF f # NIL THEN
			g.file.size := Files.Length(f);
			Kernel.GetClock(t, d);
			g.file.date := SHORT(d); g.file.time := SHORT(t DIV 2);
			findFile(g.file.name, h);
			IF h.file.name = g.file.name THEN
				needC := Clusters(g.file.size) - Clusters(h.file.size);
				IF usedC + needC <= 720 THEN
					deleteFile(h); addFile(f, g, h.next);
					usedC := usedC + needC
				ELSE res := 2
				END
    		ELSE needC := Clusters(g.file.size);
			    IF (usedF < 112) & (usedC + needC <= 720) THEN
				    addFile(f, g, h);
				    INC(usedF); usedC := usedC + needC
			    ELSE res := 2
                END
			END
		ELSE res := 1
		END
	END WriteFile;

	PROCEDURE DeleteFile* (name: ARRAY OF CHAR);
		VAR g: File;
	BEGIN
	    findFile(name, g);
		IF g.file.name = name THEN
		    deleteFile(g); DEC(usedF); usedC := usedC - Clusters(g.file.size); res := 0
		ELSE res := 1
		END
	END DeleteFile;

BEGIN trailer.name[0] := 0X
END Diskette.



