MODULE TextPrinter;	(** CAS/MH/HM 23.9.1993 **)
	IMPORT
		Files, Display, Fonts, Printer, Texts, TextFrames;

	CONST
		Unit* = 3048;	(**unit for a 300 dpi printer**)
		unit = TextFrames.Unit;
		mm = TextFrames.mm; Scale = mm DIV 10;

		gridAdj = TextFrames.gridAdj;
		leftAdj = TextFrames.leftAdj; rightAdj = TextFrames.rightAdj; AdjMask = {leftAdj, rightAdj};
		pageBreak = TextFrames.pageBreak;
		twoColumns = TextFrames.twoColumns;
		AdjustSpan = 30; MinTabWidth = 1 * Scale; StdTabWidth = 4 * mm;
		ColumnGap = 7*mm;

		TAB = 9X; CR = 0DX;
		MaxDict = 32;	MaxLine = 512;

	TYPE
		PrintMsg* = RECORD (Texts.ElemMsg)
			prepare*: BOOLEAN;
			indent*: LONGINT;	(**prepare => width already consumed in line, in units**)
			fnt*: Fonts.Font;
			col*: SHORTINT;
			pos*: LONGINT;	(**position in host text**)
			X0*, Y0*, pno*: INTEGER	(**receiver origin in screen space; page number**)
		END;

		PrintLine = RECORD
			eot: BOOLEAN;	(*marked to skip, contains end of text*)
			indent: LONGINT;
			w, h, dsr: INTEGER;	(*bounding box clipped to frame*)
			nob: INTEGER;	(*number of contained blanks; > 0 if text line wraps around*)
			org, len, span: LONGINT;	(*len w/o; span w/ trailing CR or white space, if any*)
			pbeg: LONGINT	(*position of corresponding parc*)
		END;

	VAR
		P: TextFrames.Parc;
		pbeg: LONGINT;
		R: Texts.Reader;
		nextCh: CHAR;
		fname: ARRAY 32 OF CHAR;

		fonts: RECORD
			num: SHORTINT;
			dict: ARRAY MaxDict OF Fonts.Font;
			dx: ARRAY MaxDict, 256 OF SHORTINT
		END;
		line: RECORD
			first: BOOLEAN;
			fno: SHORTINT;
			px, x, y: INTEGER;
			len: INTEGER;
			buf: ARRAY MaxLine OF CHAR
		END;


	PROCEDURE Min (x, y: LONGINT): LONGINT;
	BEGIN
		IF x < y THEN RETURN x ELSE RETURN y END
	END Min;

	PROCEDURE Max (x, y: INTEGER): INTEGER;
	BEGIN
		IF x > y THEN RETURN x ELSE RETURN y END
	END Max;

	PROCEDURE Append (VAR s1: ARRAY OF CHAR; i: INTEGER; s2: ARRAY OF CHAR);
		VAR j: INTEGER;
	BEGIN j := 0;	(*s1 large enough*)
		WHILE s2[j] # 0X DO s1[i] := s2[j]; INC(i); INC(j) END;
		s1[i] := 0X
	END Append;


	(** Printer Metrics **)

	PROCEDURE SetMetrics (fno: SHORTINT; fnt: Fonts.Font);
		VAR f: Files.File; r: Files.Rider; pat: Display.Pattern;
			off, i, j, k, dx, x, y, w, h: INTEGER; size, s: SHORTINT; mod, m: CHAR;
			name: ARRAY 32 OF CHAR;
	BEGIN COPY(fnt.name, name);
		i := 0; WHILE name[i] > "9" DO INC(i) END;
		j := i; WHILE ("0" <= name[j]) & (name[j] < "9") DO INC(j) END;
		k := j; WHILE (name[k] # ".") & (name[k] # 0X) DO INC(k) END;
		IF k > j THEN mod := name[k-1] ELSE mod := " " END;
		size := 0; k := i; WHILE i < j DO size := 10 * size + SHORT(ORD(name[i]) - 30H); INC(i) END;
		Append(name, k, ".Lm3.Fnt"); f := Files.Old(name);
		IF f # NIL THEN Files.Set(r, f, 2); Files.ReadInt(r, off); Files.Set(r, f, 6); i := -1;
			REPEAT INC(i); Files.Read(r, s); Files.Read(r, m) UNTIL (s = size) & (m = mod) OR (Files.Pos(r) >= off);
			IF (s = size) & (m = mod) THEN Files.Set(r, f, off + i * 260 + 4); Files.ReadBytes(r, fonts.dx[fno], 256)
			ELSE f := NIL
			END
		END;
		IF f = NIL THEN i := 0;	(*no printer metrics file found - construct from screen metrics*)
			WHILE i < 256 DO Display.GetChar(fnt.raster, CHR(i), dx, x, y, w, h, pat);
				fonts.dx[fno, i] := SHORT(SHORT(LONG(dx) * unit * 12 DIV 10 DIV Unit)); INC(i)
				(*+20% : heuristical correction*)
			END
		END
	END SetMetrics;

	PROCEDURE FontNo* (fnt: Fonts.Font): SHORTINT;
		VAR fno: SHORTINT;
	BEGIN fno := 0; fonts.dict[fonts.num] := fnt;
		WHILE fonts.dict[fno] # fnt DO INC(fno) END;
		IF fno = fonts.num THEN SetMetrics(fno, fnt); INC(fonts.num) END;
		RETURN fno
	END FontNo;

	PROCEDURE Font* (fno: SHORTINT): Fonts.Font;
	BEGIN RETURN fonts.dict[fno]
	END Font;

	PROCEDURE DX* (fno: SHORTINT; ch: CHAR): LONGINT;
	BEGIN RETURN LONG(LONG(fonts.dx[fno, ORD(ch)])) * Unit
	END DX;

	PROCEDURE Get* (fno: SHORTINT; ch: CHAR; VAR dx, x, y, w, h: LONGINT);
		VAR pat: Display.Pattern; dx0, x0, y0, w0, h0: INTEGER;
	BEGIN Display.GetChar(fonts.dict[fno].raster, ch, dx0, x0, y0, w0, h0, pat);
		x := LONG(x0) * unit; y := LONG(y0) * unit; h := LONG(h0) * unit;
		dx := LONG(LONG(fonts.dx[fno, ORD(ch)])) * Unit; w := dx
	END Get;

	PROCEDURE GetChar* (fno: SHORTINT; targetUnit: LONGINT; ch: CHAR;
				VAR pdx: LONGINT; VAR dx, x, y, w, h: INTEGER; VAR pat: Display.Pattern);
	BEGIN Display.GetChar(fonts.dict[fno].raster, ch, dx, x, y, w, h, pat);
		x := SHORT(x * LONG(unit) DIV targetUnit); y := SHORT(y * LONG(unit) DIV targetUnit);
		h := SHORT(h * LONG(unit) DIV targetUnit);
		pdx := LONG(LONG(fonts.dx[fno, ORD(ch)])) * Unit;
		dx := SHORT(pdx DIV targetUnit); w := dx
	END GetChar;

	PROCEDURE InitFonts*;
		VAR fno: SHORTINT;
	BEGIN fonts.num := 0; fno := FontNo(Fonts.Default)
	END InitFonts;

	PROCEDURE Width (fno: SHORTINT; VAR s: ARRAY OF CHAR): INTEGER;
		VAR i, w: INTEGER;
	BEGIN i := 0; w := 0;
		WHILE s[i] # 0X DO INC(w, LONG(fonts.dx[fno, ORD(s[i])]) ); INC(i) END;
		RETURN w
	END Width;

	PROCEDURE GetPrintChar (fnt: Fonts.Font; ch: CHAR; VAR fno: SHORTINT; VAR dx, x, y, w, h: INTEGER);
		VAR pat: Display.Pattern;
	BEGIN Display.GetChar(fnt.raster, ch, dx, x, y, w, h, pat);
		x := SHORT(x * LONG(unit) DIV Unit); y := -SHORT((-y) * LONG(unit) DIV Unit);
		h := SHORT(h * LONG(unit) DIV Unit);
		fno := FontNo(fnt); dx := fonts.dx[fno, ORD(ch)]; w := dx
	END GetPrintChar;

	PROCEDURE Tab (dw: INTEGER; VAR dx: INTEGER);	(*P set*)
		VAR i, n: INTEGER; w: LONGINT;
	BEGIN i := 0; n := P.nofTabs; w := LONG(dw) * Unit + MinTabWidth;
		IF dw < 0 THEN dx := -dw
		ELSE
			WHILE (i < n) & (P.tab[i] < w) DO INC(i) END;
			IF i < n THEN dx := SHORT((P.tab[i] - LONG(dw) * Unit) DIV Unit)
			ELSE dx := StdTabWidth DIV Unit
			END
		END
	END Tab;

	PROCEDURE Offset (): INTEGER;	(*R set*)
	BEGIN
		IF R.voff = 0 THEN RETURN 0
		ELSE RETURN SHORT(R.fnt.height * R.voff * LONG(unit) DIV 64 DIV Unit)
		END
	END Offset;

	PROCEDURE MeasureSpecial (pno, dw: INTEGER; VAR fno: SHORTINT; VAR dx, x, y, w, h: INTEGER);
		(*P, R, nextCh set*)
		VAR e: Texts.Elem; i: INTEGER; msg: PrintMsg;
	BEGIN
		IF nextCh = " " THEN GetPrintChar(R.fnt, nextCh, fno, dx, x, y, w, h);
			x := 0; y := 0; w := dx; h := 0
		ELSIF nextCh = TAB THEN Tab(dw, dx); x := 0; y := 0; w := dx; h := 0
		ELSIF R.elem # NIL THEN e := R.elem;
			msg.prepare := TRUE; msg.indent := LONG(dw) * Unit;
			msg.fnt := R.fnt; msg.col := R.col; msg.pos := Texts.Pos(R) - 1; msg.pno := pno;
			msg.Y0 := -SHORT(P.dsr DIV Unit);
			e.handle(e, msg);
			w := SHORT(e.W DIV Unit); dx := w; h := SHORT(e.H DIV Unit);
			x := 0; y := msg.Y0
		ELSE GetPrintChar(R.fnt, nextCh, fno, dx, x, y, w, h)
		END
	END MeasureSpecial;

	PROCEDURE GetSpecial (VAR n: INTEGER; maxW, cn, ddx, dw: INTEGER;
			VAR fno: SHORTINT; VAR dx, x, y, w, h: INTEGER);	(*P, R, nextCh set*)
		VAR e: Texts.Elem;
	BEGIN
		IF nextCh = " " THEN GetPrintChar(R.fnt, nextCh, fno, dx, x, y, w, h);
			x := 0; y := 0; INC(dx, ddx); INC(n); IF n <= cn THEN INC(dx) END;	(*space correction for block adjustment*)
			w := dx; h := 0
		ELSIF nextCh = TAB THEN Tab(dw, dx); x := 0; y := 0; w := dx; h := 0
		ELSIF R.elem # NIL THEN e := R.elem;
				IF e IS TextFrames.Parc THEN w := SHORT(Min(P.width DIV Unit, maxW)); e.W := LONG(w) * Unit
				ELSE w := SHORT(e.W DIV Unit)
				END;
				dx := w; x := 0; y := -SHORT(P.dsr DIV Unit); h := SHORT(e.H DIV Unit)
		ELSE GetPrintChar(R.fnt, nextCh, fno, dx, x, y, w, h)
		END
	END GetSpecial;

	PROCEDURE AdjustMetrics (T: Texts.Text; VAR t: PrintLine; left: INTEGER; VAR pw, tw, ddx, cn: INTEGER);
		(*sets P, pbeg*)
	BEGIN pw := left; tw := t.w; ddx := 0; cn := 0;
		TextFrames.ParcBefore(T, t.org, P, pbeg);
		IF pbeg # t.org THEN
			INC(pw, SHORT((P.left + t.indent) DIV Unit));
			DEC(tw, SHORT(t.indent DIV Unit));
			IF leftAdj IN P.opts THEN
				IF (rightAdj IN P.opts) & (t.nob > 0) THEN
					tw := SHORT((P.width - t.indent) DIV Unit); ddx := (tw - t.w) DIV t.nob; cn := (tw - t.w) MOD t.nob
				END
			ELSIF rightAdj IN P.opts THEN INC(pw, SHORT(P.width DIV Unit) - t.w)
			ELSE (*center*) INC(pw, (SHORT(P.width DIV Unit) - t.w) DIV 2)
			END
		END
	END AdjustMetrics;


	(* Printer Line Casting *)

	PROCEDURE MeasureLine (T: Texts.Text; pno, maxW: INTEGER; VAR t: PrintLine);	(*R, nextCh set*)
		VAR len, bklen, d: LONGINT; eol: BOOLEAN; fno: SHORTINT;
			nob, bknob, width, minY, bkminY, maxY, bkmaxY, tw, bktw, lsp, dsr, dx, x, y, w, h: INTEGER;
			R1: Texts.Reader; peekCh: CHAR;
	BEGIN len := 0; nob := 0; bklen := -999; tw := 0; dx := 0; minY := 0; maxY := 0;
		TextFrames.ParcBefore(T, t.org, P, pbeg);
		lsp := SHORT(P.lsp DIV Unit); dsr := SHORT(P.dsr DIV Unit); width := SHORT(P.width DIV Unit);
		t.indent := 0;
		IF t.org > 0 THEN Texts.OpenReader(R1, T, t.org - 1); Texts.Read(R1, peekCh);
			IF (peekCh = CR) OR (R1.elem # NIL) & (R1.elem IS TextFrames.Parc) THEN t.indent := P.first END;
		END;
		DEC(width, SHORT(t.indent DIV Unit));
		LOOP INC(tw, dx);
			IF R.eot OR (nextCh = CR) THEN nob := 0; eol := ~R.eot; EXIT END;
			IF nextCh <= " " THEN MeasureSpecial(pno, tw + SHORT(t.indent DIV Unit), fno, dx, x, y, w, h)
			ELSE GetPrintChar(R.fnt, nextCh, fno, dx, x, y, w, h)
			END;
			IF tw + x + dx > width THEN d := len - bklen;
				IF (0 <= d) & (d < AdjustSpan) & (nextCh > " ") THEN eol := TRUE;
					Texts.OpenReader(R, T, Texts.Pos(R) - d);
					nob := bknob; len := bklen; tw := bktw; minY := bkminY; maxY := bkmaxY
				ELSIF len = 0 THEN	(*force at least one character on each line*)
					INC(len); INC(y, Offset()); minY := SHORT(Min(minY, y)); maxY := Max(maxY, y + h);
					Texts.Read(R, nextCh); eol := FALSE
				ELSE eol := (nextCh <= " ") & (nextCh # Texts.ElemChar)
				END;
				EXIT
			END;
			IF (nextCh <= " ") & (nextCh # Texts.ElemChar) THEN
				bknob := nob; bklen := len; bktw := tw; bkminY := minY; bkmaxY := maxY;
				IF nextCh = " " THEN INC(nob) END
			END;
			INC(len); INC(y, Offset()); minY := SHORT(Min(minY, y)); maxY := Max(maxY, y + h);
			Texts.Read(R, nextCh)
		END;
		IF gridAdj IN P.opts THEN
			WHILE dsr < -minY DO INC(dsr, lsp) END;
			t.h := Max(lsp, dsr + maxY); INC(t.h, (-t.h) MOD lsp)
		ELSE dsr := Max(dsr, -minY); t.h := Max(lsp, dsr + maxY)
		END;
		t.len := len; t.w := SHORT(Min(tw, maxW)); t.dsr := dsr; t.nob := nob; t.eot := R.eot; t.pbeg := pbeg;
		IF eol THEN Texts.Read(R, nextCh); t.span := len + 1 ELSE t.span := len END
	END MeasureLine;


	(** Printer Page Placement **)

	PROCEDURE FlushLine;
	BEGIN
		IF line.len > 0 THEN line.buf[line.len] := 0X; line.len := 0;
			IF line.first THEN Printer.String(line.px, line.y, line.buf, fonts.dict[line.fno].name); line.first := FALSE
			ELSE Printer.ContString(line.buf, fonts.dict[line.fno].name)
			END
		END
	END FlushLine;

	PROCEDURE PlaceChar (ch: CHAR; fno: SHORTINT; x, y, dx: INTEGER);
	BEGIN
		IF line.len > 0 THEN
			IF (x # line.x) OR (y # line.y) THEN FlushLine; line.first := TRUE; line.px := x
			ELSIF fno # line.fno THEN FlushLine
			END
		ELSE line.px := x
		END;
		line.fno := fno; line.x := x + dx; line.y := y; line.buf[line.len] := ch; INC(line.len)
	END PlaceChar;

	PROCEDURE PlaceSpecial (fno: SHORTINT; pno, nob, px, py, x, y, dx: INTEGER);	(*R, nextCh set*)
		VAR e: Texts.Elem; msg: PrintMsg;
	BEGIN
		IF (nextCh = " ") & (P.opts * AdjMask = AdjMask) & (nob > 0) OR (nextCh = TAB) THEN (*skip*)
		ELSIF R.elem # NIL THEN e := R.elem;
			FlushLine; line.first := TRUE;
			msg.prepare := FALSE;
			msg.fnt := R.fnt; msg.col := R.col; msg.pos := Texts.Pos(R) - 1;
			msg.X0 := px + x; msg.Y0 := py + y; msg.pno := pno;
			e.handle(e, msg)
		ELSE PlaceChar(nextCh, fno, px, py, dx)
		END
	END PlaceSpecial;

	PROCEDURE PlaceLine (T: Texts.Text; pno: INTEGER; VAR t: PrintLine; left, width, py: INTEGER);
		VAR i: LONGINT; n, cn, lm, rm, px, pw, tw, ddx, dx, x, y, w, h: INTEGER; fno: SHORTINT;
	BEGIN Texts.OpenReader(R, T, t.org); AdjustMetrics(T, t, left, pw, tw, ddx, cn);
		lm := left + SHORT(P.left DIV Unit); rm := left + width; px := pw; INC(py, t.dsr); i := 0; n := 0;
		line.first := TRUE; line.len := 0;
		WHILE i < t.len DO Texts.Read(R, nextCh);
			IF nextCh <= " " THEN GetSpecial(n, width, cn, ddx, px - lm, fno, dx, x, y, w, h)
			ELSE GetPrintChar(R.fnt, nextCh, fno, dx, x, y, w, h)
			END;
			IF px + x + w <= rm THEN
				IF nextCh <= " " THEN PlaceSpecial(fno, pno, t.nob, px, py, x, y + Offset(), dx)
				ELSE PlaceChar(nextCh, fno, px, py + Offset(), dx)
				END;
				INC(px, dx); INC(i)
			ELSE i := t.len
			END
		END;
		FlushLine
	END PlaceLine;


	PROCEDURE PlaceHeader* (headerX, headerY, headerW: INTEGER;
			pno: INTEGER; fnt: Fonts.Font; VAR header: ARRAY OF CHAR; alt: BOOLEAN);
		VAR i, j: INTEGER; fno: SHORTINT; digits, pageno: ARRAY 16 OF CHAR;
	BEGIN alt := alt & ~ODD(pno); fno := FontNo(fnt);
		IF (pno >= 0) OR (pno < -30) THEN pno := ABS(pno); i := 0; j := 0;
			REPEAT digits[i] := CHR(pno MOD 10 + 30H); INC(i); pno := pno DIV 10 UNTIL pno = 0;
			REPEAT DEC(i); pageno[j] := digits[i]; INC(j) UNTIL i = 0;
			pageno[j] := 0X
		ELSE pno := ABS(pno); i := 0;
			WHILE pno >= 10 DO DEC(pno, 10); pageno[i] := "x"; INC(i) END;
			CASE pno OF
				0:
			|   1..3: WHILE pno > 0 DO DEC(pno); pageno[i] := "i"; INC(i) END
			|   4: pageno[i] := "i"; INC(i); pageno[i] := "v"; INC(i)
			|   5..8: DEC(pno, 5); pageno[i] := "v"; INC(i);
					WHILE pno > 0 DO DEC(pno); pageno[i] := "i"; INC(i) END
			|   9: pageno[i] := "i"; INC(i); pageno[i] := "x"; INC(i)
			END;
			pageno[i] := 0X
		END;
		IF alt THEN Printer.String(headerX, headerY, pageno, fonts.dict[fno].name);
			IF header[0] # 0X THEN
				Printer.String(headerX + headerW - Width(fno, header), headerY, header, fonts.dict[fno].name)
			END
		ELSE Printer.String(headerX + headerW - Width(fno, pageno), headerY, pageno, fonts.dict[fno].name);
			IF header[0] # 0X THEN Printer.String(headerX, headerY, header, fonts.dict[fno].name) END
		END
	END PlaceHeader;


	PROCEDURE ClaimPrinter;	(*send null-command to keep printer connection alive*)
		VAR i: INTEGER; dmy: ARRAY 32 OF CHAR;
	BEGIN dmy[0] := 0X; i := 10;
		WHILE i > 0 DO Printer.String(0, 0, dmy, fname); DEC(i) END
	END ClaimPrinter;

	(*PROCEDURE PrintDraft* (t: Texts.Text; header: ARRAY OF CHAR; copies: INTEGER);
		CONST left = 160; bot = 100; lsp = 32;
		VAR top, y, pno, i: INTEGER; r: Texts.Reader; ch: CHAR; s: ARRAY 256 OF CHAR;
	
		PROCEDURE PrintHeader;
		BEGIN
			Printer.String(left, Printer.PageHeight - 125, header, Fonts.Default.name);
			IF pno < 10 THEN s[0] := " " ELSE s[0] := CHR(30H + pno MOD 100 DIV 10) END;
			s[1] := CHR(30H + pno MOD 10); s[2] := 0X;
			Printer.String(Printer.PageWidth - 236, Printer.PageHeight - 125, s, Fonts.Default.name)
		END PrintHeader;
	
	BEGIN
		pno := 0; top := Printer.PageHeight - 225; y := top;
		Printer.UseListFont(Fonts.Default.name);
		PrintHeader;
		Texts.OpenReader(r, t, 0);
		REPEAT Texts.Read(r, ch);
			i := 0; WHILE ~r.eot & (ch # CR) DO s[i] := ch; INC(i); Texts.Read(r, ch) END;
			s[i] := 0X;
			Printer.String(left, y, s, Fonts.Default.name);
			y := y - lsp;
			IF y < bot THEN Printer.Page(copies); INC(pno); PrintHeader; y := top END
		UNTIL r.eot;
		IF y < top THEN Printer.Page(copies) END
	END PrintDraft;*)

	PROCEDURE PrintDraft* (t: Texts.Text; header: ARRAY OF CHAR; copies: INTEGER);
		CONST left = 160; bot = 100; lsp = 32; maxLineLen = 120;
		VAR top, y, pno, i, b: INTEGER; org: LONGINT; r: Texts.Reader; ch: CHAR; s: ARRAY maxLineLen + 1 OF CHAR;
	
		PROCEDURE PrintHeader;
		BEGIN
			Printer.String(left, Printer.PageHeight - 125, header, Fonts.Default.name);
			IF pno < 10 THEN s[0] := " " ELSE s[0] := CHR(30H + pno MOD 100 DIV 10) END;
			s[1] := CHR(30H + pno MOD 10); s[2] := 0X;
			Printer.String(Printer.PageWidth - 236, Printer.PageHeight - 125, s, Fonts.Default.name)
		END PrintHeader;
	
	BEGIN
		pno := 0; top := Printer.PageHeight - 225; y := top;
		Printer.UseListFont(Fonts.Default.name);
		PrintHeader;
		Texts.OpenReader(r, t, 0);
		REPEAT
			org := Texts.Pos(r); Texts.Read(r, ch); i := 0; b := 0;
			WHILE ~r.eot & (ch # CR) & (i < maxLineLen) DO
				IF ch = " " THEN b := i END;
				s[i] := ch; INC(i); Texts.Read(r, ch)
			END;
			IF (i = maxLineLen) & (ch # CR) & ~r.eot THEN
				IF b > 0 THEN i := b; org := org + i + 1 ELSE org := org + i END;
				Texts.OpenReader(r, t, org)
			END;
			s[i] := 0X;
			Printer.String(left, y, s, Fonts.Default.name);
			y := y - lsp;
			IF y < bot THEN Printer.Page(copies); INC(pno); PrintHeader; y := top END
		UNTIL r.eot;
		IF y < top THEN Printer.Page(copies) END
	END PrintDraft;

(*---version without two-column printing
	PROCEDURE PlaceBody* (bodyX, bodyY, bodyW, bodyH: INTEGER;
			T: Texts.Text; VAR pos: LONGINT; pno: INTEGER; place: BOOLEAN);
		VAR t: PrintLine; org: LONGINT; py: INTEGER; inPage: BOOLEAN;
	BEGIN py := bodyY + bodyH; inPage := FALSE;
		LOOP org := pos; Texts.OpenReader(R, T, org); Texts.Read(R, nextCh);
			t.org := org; MeasureLine(T, pno, bodyW, t);
			IF pbeg = org THEN
				IF inPage & (pageBreak IN P.opts) THEN EXIT	(*parc enforced early page break*)
				ELSIF py - bodyY < SHORT((3 * P.lsp + P.lead) DIV Unit) THEN	(*widow window*)
					INC(pos, t.span); EXIT
				ELSIF inPage OR (pageBreak IN P.opts) THEN DEC(py, SHORT(P.lead DIV Unit)); inPage := TRUE
				END
			ELSE inPage := inPage OR (t.len > 0);
				IF inPage THEN DEC(py, t.h) END;
				IF py < bodyY THEN EXIT END;
				IF place THEN PlaceLine(T, pno, t, bodyX, bodyW + (5 * mm DIV Unit), py)
				ELSE ClaimPrinter
				END
			END;
			INC(pos, t.span);
			IF t.eot THEN EXIT END
		END
	END PlaceBody;
*)
(*---*)
	PROCEDURE MeasureColumns (pno, py, y0, w0: INTEGER; T: Texts.Text; VAR pos: LONGINT;
			VAR t: ARRAY OF PrintLine; VAR nl, nr, bh: INTEGER; VAR eofPage: BOOLEAN);
		VAR yl, yr, hl, hr, dh: INTEGER; inColumn, break: BOOLEAN;

		PROCEDURE MeasureColumn (VAR inCol, break: BOOLEAN; lastCol: BOOLEAN; VAR py: INTEGER; VAR n: INTEGER);
			VAR org: LONGINT; eot: BOOLEAN;
		BEGIN
			LOOP org := pos; Texts.OpenReader(R, T, org); Texts.Read(R, nextCh);
				t[n].org := org; MeasureLine(T, pno, w0, t[n]); eot := t[n].eot;
				IF ~(twoColumns IN P.opts) OR (n = LEN(t)) THEN EXIT END;
				IF pbeg = org THEN
					IF inCol & (pageBreak IN P.opts) THEN break := TRUE; EXIT	(*parc enforced early page break*)
					ELSIF lastCol & (py - y0 < SHORT((3 * P.lsp + P.lead) DIV Unit)) THEN	(*widow window*)
						t[n].h := SHORT(P.lead DIV Unit); INC(pos, t[n].span); eofPage := TRUE; EXIT
					ELSIF inCol OR (pageBreak IN P.opts) THEN inCol := TRUE;
						t[n].h := SHORT(P.lead DIV Unit); DEC(py, t[n].h)
					END;
					INC(pos, t[n].span); INC(n)
				ELSIF inCol OR (t[n].len > 0) THEN inCol := TRUE;
					IF py - t[n].h >= y0 THEN DEC(py, t[n].h); INC(pos, t[n].span); INC(n)
					ELSE eofPage := TRUE; EXIT
					END
				ELSE INC(pos, t[n].span)
				END;
				ClaimPrinter;
				IF eot THEN EXIT END
			END
		END MeasureColumn;

	BEGIN inColumn := FALSE; break := FALSE; dh := 0;
		yl := py; nl := 0; MeasureColumn(inColumn, break, FALSE, yl, nl); hl := py - yl;
		yr := py; nr := nl;
		IF ~break THEN MeasureColumn(inColumn, break, TRUE, yr, nr) END;
		hr := py - yr;
		LOOP	(*balance columns*)
			IF nl = 0 THEN EXIT
			ELSIF t[nl-1].len = 0 THEN DEC(nl); dh := t[nl].h;
			ELSIF (hl - t[nl - 1].h > hr) & (yr - t[nl - 1].h >= y0) THEN DEC(nl);
				DEC(hl, t[nl].h); INC(yl, t[nl].h); INC(hr, t[nl].h + dh); DEC(yr, t[nl].h + dh); dh := 0
			ELSE EXIT
			END
		END;
		bh := Max(hl, hr)
	END MeasureColumns;

	PROCEDURE PlaceColumns (T: Texts.Text; VAR t: ARRAY OF PrintLine; pno, px, py, w0, nl, nr: INTEGER);
		VAR i, x, y, w: INTEGER;
	BEGIN i := 0;
		x := px; y := py; w := w0 + (5 * mm DIV Unit);
		WHILE i < nl DO DEC(y, t[i].h); PlaceLine(T, pno, t[i], x, w, y); INC(i) END;
		x := px + (w0 + ColumnGap DIV Unit) DIV 2;
		y := py; w := w0 DIV 2 + (5 * mm DIV Unit);
		WHILE (i < nr) & ((t[i].len = 0) OR (t[i].pbeg = t[i].org)) DO INC(i) END;
		WHILE i < nr DO DEC(y, t[i].h); PlaceLine(T, pno, t[i], x, w, y); INC(i) END
	END PlaceColumns;

	PROCEDURE PlaceBody* (bodyX, bodyY, bodyW, bodyH: INTEGER;
			T: Texts.Text; VAR pos: LONGINT; pno: INTEGER; place: BOOLEAN);
		VAR t: PrintLine; org: LONGINT; py, bh, nl, nr: INTEGER; inPage, eofPage: BOOLEAN;
			bt: ARRAY 254 OF PrintLine;
	BEGIN py := bodyY + bodyH; inPage := FALSE;
		LOOP org := pos; Texts.OpenReader(R, T, org); Texts.Read(R, nextCh);
			t.org := org; MeasureLine(T, pno, bodyW, t);
			IF pbeg = org THEN
				IF inPage & (pageBreak IN P.opts) THEN EXIT	(*parc enforced early page break*)
				ELSIF py - bodyY < SHORT((3 * P.lsp + P.lead) DIV Unit) THEN	(*widow window*)
					INC(pos, t.span); EXIT
				ELSIF inPage OR (pageBreak IN P.opts) THEN DEC(py, SHORT(P.lead DIV Unit)); inPage := TRUE
				END;
				INC(pos, t.span)
			ELSIF twoColumns IN P.opts THEN eofPage := FALSE;
				MeasureColumns(pno, py, bodyY, bodyW, T, pos, bt, nl, nr, bh, eofPage);
				IF (nl = 0) OR (bh = 0) THEN EXIT END;
				IF place THEN PlaceColumns(T, bt, pno, bodyX, py, bodyW, nl, nr) END;
				DEC(py, bh); inPage := TRUE;
				IF eofPage THEN EXIT END
			ELSE inPage := inPage OR (t.len > 0);
				IF inPage THEN DEC(py, t.h) END;
				IF py < bodyY THEN
					IF t.h > bodyH THEN INC(pos, t.span) END;	(*line is higher than page: skip*)
					EXIT
				END;
				IF place THEN PlaceLine(T, pno, t, bodyX, bodyW + (5 * mm DIV Unit), py)
				ELSE ClaimPrinter
				END;
				INC(pos, t.span)
			END;
			IF t.eot THEN EXIT END
		END
	END PlaceBody;
(*---*)

BEGIN fname := "Syntax10.Scn.Fnt"
END TextPrinter.
