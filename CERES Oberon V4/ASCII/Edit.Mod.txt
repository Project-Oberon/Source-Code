MODULE Edit;	(** CAS/MH/HM 27.4.1994 / NW 15.11.94 **)
	IMPORT
		Modules, Oberon, Display, Viewers, MenuViewers, Fonts, Printer,
		Texts, TextFrames, ParcElems, TextPrinter;

	CONST
		Menu = "^Edit.Menu.Text System.Close  System.Copy  System.Grow  Edit.Search  Edit.Replace  Edit.Parcs  Edit.Store ";
		OptionChar = "/";

		mm = TextFrames.mm; Unit = TextPrinter.Unit;
		Scale = mm DIV 10;	(*unit of user setable attributes is 1/10 mm*)

		headerX = 15 * mm DIV Unit;
		headerW = 165 * mm DIV Unit;
		bodyX = 15 * mm DIV Unit; bodyY = 15 * mm DIV Unit;
		bodyW = 165 * mm DIV Unit;

		MaxPat = 128;
		CR = 0DX;

	VAR
		R: Texts.Reader;
		W: Texts.Writer;
		mnam: ARRAY 12*3 + 1 OF CHAR;

		find: RECORD
			time, len: LONGINT;
			buf: ARRAY MaxPat OF CHAR
		END;
		repl: RECORD
			time: LONGINT;
			buf: Texts.Buffer
		END;


	PROCEDURE Ch (ch: CHAR);
	BEGIN Texts.Write(W, ch); Texts.Append(Oberon.Log, W.buf)
	END Ch;

	PROCEDURE Str (s: ARRAY OF CHAR);
	BEGIN Texts.WriteString(W, s); Texts.Append(Oberon.Log, W.buf)
	END Str;

	PROCEDURE Int (n: LONGINT);
	BEGIN Texts.Write(W, " "); Texts.WriteInt(W, n, 0); Texts.Append(Oberon.Log, W.buf)
	END Int;

	PROCEDURE Ln;
	BEGIN Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)
	END Ln;


	PROCEDURE Min (x, y: LONGINT): LONGINT;
	BEGIN
		IF x < y THEN RETURN x ELSE RETURN y END
	END Min;


	PROCEDURE AppendNum (VAR s: ARRAY OF CHAR; VAR i: INTEGER; n: LONGINT);
		VAR j: INTEGER; digits: ARRAY 16 OF CHAR;
	BEGIN j := 0;
		REPEAT digits[j] := CHR(n MOD 10 + 30H); INC(j); n := n DIV 10 UNTIL n = 0;
		REPEAT DEC(j); s[i] := digits[j]; INC(i) UNTIL j = 0;
		s[i] := 0X
	END AppendNum;

	PROCEDURE AppendDate (VAR s: ARRAY OF CHAR);	(*s := s & "   (dd mmm yy)"*)
		VAR time, date: LONGINT; i, j, k, m: INTEGER;
	BEGIN Oberon.GetClock(time, date); i := 0;
		WHILE s[i] # 0X DO INC(i) END;
		s[i] := " "; s[i + 1] := " "; s[i + 2] := " "; s[i + 3] := "("; INC(i, 4);
		AppendNum(s, i, date MOD 20H); s[i] := " "; INC(i);
		m := SHORT((date DIV 20H) MOD 10H); k := m * 3; j := k - 3;
		REPEAT s[i] := mnam[j]; INC(i); INC(j) UNTIL j = k;
		s[i] := " "; INC(i); AppendNum(s, i, (date DIV 200H) MOD 100);
		s[i] := ")"; s[i + 1] := 0X
	END AppendDate;

	PROCEDURE ShowAliens (t: Texts.Text);
		VAR R: Texts.Reader; identify: Texts.IdentifyMsg;
	BEGIN
		Texts.OpenReader(R, t, 0); Texts.ReadElem(R);
		WHILE ~R.eot DO identify.mod[31] := 0X; R.elem.handle(R.elem, identify);
			IF identify.mod[31] = 1X THEN Ln; Str("pos"); Int(Texts.Pos(R) - 1);
				Str("  unknown element allocator: "); Str(identify.mod); Ch("."); Str(identify.proc)
			END;
			Texts.ReadElem(R)
		END;
		IF W.buf.len > 0 THEN Ln; Texts.Append(Oberon.Log, W.buf) END
	END ShowAliens;


	(* view support *)

	PROCEDURE ShowPos (F: TextFrames.Frame; pos: LONGINT);
		VAR beg, end, delta: LONGINT;
	BEGIN delta := 200;
		LOOP beg := F.org; end := TextFrames.Pos(F, F.X + F.W, F.Y);
			IF (beg <= pos) & (pos < end) OR (delta = 0) THEN EXIT END;
			TextFrames.Show(F, pos - delta); delta := delta DIV 2
		END
	END ShowPos;

	PROCEDURE SetCaret (F: TextFrames.Frame; pos: LONGINT);
	BEGIN Oberon.PassFocus(Viewers.This(F.X, F.Y)); TextFrames.SetCaret(F, pos)
	END SetCaret;

	PROCEDURE NewView (name: ARRAY OF CHAR; class: INTEGER;
			T: Texts.Text; org: LONGINT): TextFrames.Frame;
		VAR V: MenuViewers.Viewer; F, M: TextFrames.Frame; i, x, y: INTEGER;
	BEGIN
		IF class = Texts.String THEN i := 0;
			WHILE name[i] # 0X DO INC(i) END;
			name[i] := 22X; INC(i); name[i] := 0X;
			WHILE i >= 0 DO name[i+1] := name[i]; DEC(i) END;
			name[0] := 22X
		END;
		F := TextFrames.NewText(T, org);
		Oberon.AllocateUserViewer(Oberon.Mouse.X, x, y);
		M := TextFrames.NewMenu(name, Menu);
		V := MenuViewers.New(M, F, TextFrames.menuH, x, y);
		ShowPos(F, org); RETURN F
	END NewView;


	(* search & replace *)

	PROCEDURE Find (T: Texts.Text; beg: LONGINT; VAR end: LONGINT);
		VAR i, j, b, e: INTEGER; ch: CHAR; ref: ARRAY MaxPat OF CHAR;	(*ref [b..e) is readback buffer*)
	BEGIN
		Texts.OpenReader(R, T, beg); Texts.Read(R, ch); i := 0; ref[0] := ch; j := 0; b := 0; e := 1;
		WHILE ~R.eot & (i < find.len) DO
			IF (find.buf[i] = ch)
				OR (find.buf[i] = 0FFX)
					& ((ch < "0") OR (ch > "9") & (ch < "A") OR (ch > "Z") & (ch < "a") OR (ch > "z"))
						THEN INC(i); j := (j + 1) MOD MaxPat
			ELSE i := 0; b := (b + 1) MOD MaxPat; j := b
			END;
			IF j # e THEN ch := ref[j]
			ELSE Texts.Read(R, ch); ref[j] := ch; e := (e + 1) MOD MaxPat; INC(beg);
			END
		END;
		IF i = find.len THEN end := beg ELSE end := -1 END
	END Find;

	PROCEDURE Check (T: Texts.Text; beg: LONGINT): BOOLEAN;
		VAR ch: CHAR; i: INTEGER;
	BEGIN i := 0;
		IF (beg >= 0) & (find.len > 0) THEN Texts.OpenReader(R, T, beg); Texts.Read(R, ch);
			WHILE ~R.eot & (i < find.len) & (ch = find.buf[i]) DO Texts.Read(R, ch); INC(i) END;
		END;
		RETURN i = find.len
	END Check;

	PROCEDURE SetReplBuf;
		VAR T: Texts.Text; beg, end, time: LONGINT;
	BEGIN Oberon.GetSelection(T, beg, end, time);
		IF time > repl.time THEN repl.time := time;
			Texts.OpenBuf(repl.buf); Texts.Save(T, beg, end, repl.buf)
		END
	END SetReplBuf;

	PROCEDURE Subst (T: Texts.Text; beg: LONGINT; VAR end: LONGINT);
	BEGIN Texts.Delete(T, beg, beg + find.len);
		IF repl.buf.len > 0 THEN end := beg + repl.buf.len;
			Texts.Insert(T, beg, repl.buf); Texts.Save(T, beg, end, repl.buf)
		END
	END Subst;


	(* arguments *)

	PROCEDURE MarkedFrame (): TextFrames.Frame;
		VAR V: Viewers.Viewer;
	BEGIN V := Oberon.MarkedViewer();
		IF (V # NIL) & (V IS MenuViewers.Viewer) & (V.dsc.next IS TextFrames.Frame) THEN
			RETURN V.dsc.next(TextFrames.Frame)
		ELSE RETURN NIL
		END
	END MarkedFrame;

	PROCEDURE FocusFrame (): TextFrames.Frame;
		VAR V: Viewers.Viewer; f: Display.Frame;
	BEGIN V := Oberon.FocusViewer;
		IF (V # NIL) & (V IS MenuViewers.Viewer) & (V.dsc # NIL) THEN f := V.dsc.next;
			IF (f # NIL) & (f IS TextFrames.Frame) THEN RETURN f(TextFrames.Frame) ELSE RETURN NIL END
		ELSE RETURN NIL
		END
	END FocusFrame;

	PROCEDURE TargetFrame (): TextFrames.Frame;	(*body frame or focus frame*)
		VAR f: Display.Frame;
	BEGIN
		IF Oberon.Par.vwr.dsc = Oberon.Par.frame THEN f := Oberon.Par.frame.next;
			IF (f # NIL) & (f IS TextFrames.Frame) THEN RETURN f(TextFrames.Frame) ELSE RETURN NIL END
		ELSE RETURN FocusFrame()
		END
	END TargetFrame;

	PROCEDURE GetMainArg (VAR S: Texts.Scanner; VAR end: LONGINT); (*takes recent selection if ^*)
		VAR text: Texts.Text; beg, time: LONGINT;
	BEGIN Texts.Scan(S); end := MAX(LONGINT);
		IF (S.class = Texts.Char) & (S.c = "^") THEN Oberon.GetSelection(text, beg, end, time);
			IF time >= 0 THEN Texts.OpenScanner(S, text, beg); Texts.Scan(S) END
		END;
		IF S.line # 0 THEN S.class := Texts.Inval END
	END GetMainArg;

	PROCEDURE GetArg (VAR S: Texts.Scanner);
		(*takes selection in command frame if ^*)
		VAR F: TextFrames.Frame;
	BEGIN
		Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
		IF (S.class = Texts.Char) & (S.c = "^") THEN F := Oberon.Par.frame(TextFrames.Frame);
			IF F.hasSel THEN 
				Texts.OpenScanner(S, F.text, F.selbeg.pos); Texts.Scan(S); F.time := 0;
			END
		END
	END GetArg;

	PROCEDURE Change (sel: SET);
		VAR S: Texts.Scanner; fnt: Fonts.Font; text: Texts.Text; beg, end, time: LONGINT; col, off: SHORTINT;
	BEGIN GetArg(S); Oberon.GetSelection(text, beg, end, time);
		IF time >= 0 THEN
			IF (sel = {0}) & (S.class = Texts.Name) THEN fnt := Fonts.This(S.s)
			ELSIF (sel = {1}) & (S.class = Texts.Int) & (0 <= S.i) & (S.i < 16) THEN col := SHORT(SHORT(S.i))
			ELSIF (sel = {2}) & (S.class = Texts.Int) & (-128 <= S.i) & (S.i < 128) THEN off := SHORT(SHORT(S.i))
			ELSE sel := {}
			END;
			IF sel # {} THEN Texts.ChangeLooks(text, beg, end, sel, fnt, col, off) END
		END
	END Change;


	(* commands *)

	PROCEDURE Locate*;
		VAR S: Texts.Scanner; F: TextFrames.Frame; text: Texts.Text; beg, end, time: LONGINT;
	BEGIN F := MarkedFrame(); Oberon.GetSelection(text, beg, end, time);
		IF time > 0 THEN Texts.OpenScanner(S, text, beg); Texts.Scan(S);
			WHILE (S.class # Texts.Int) & (S.line = 0) & ~S.eot DO Texts.Scan(S) END;
			IF (F # NIL) & (S.class = Texts.Int) & (S.line = 0) THEN ShowPos(F, S.i); SetCaret(F, S.i) END
		END;
	END Locate;

	PROCEDURE Search*;
		VAR F: TextFrames.Frame; T: Texts.Text; i, beg, end, time: LONGINT;
	BEGIN Oberon.GetSelection(T, beg, end, time); F := TargetFrame();
		IF time > find.time THEN find.time := time; find.len := Min(end - beg, MaxPat);
			Texts.OpenReader(R, T, beg); i := 0;
			REPEAT Texts.Read(R, find.buf[i]); INC(i) UNTIL i = find.len
		END;
		IF F # NIL THEN
			IF F.hasCar THEN beg := F.carloc.pos ELSE beg := 0 END;
			Find(F.text, beg, end);
			IF end >= 0 THEN ShowPos(F, end); SetCaret(F, end)
			ELSE TextFrames.RemoveCaret(F)
			END;
			TextFrames.RemoveSelection(F)
		END
	END Search;

	PROCEDURE Show*;
		VAR S: Texts.Scanner; F: TextFrames.Frame; text: Texts.Text;
			i, j, beg, end, time: LONGINT;
			name: ARRAY Modules.ModNameLen + 4 OF CHAR;
	BEGIN text := Oberon.Par.text; beg := Oberon.Par.pos; end := Oberon.Par.text.len; time := Oberon.Time();
		Texts.OpenScanner(S, text, beg); Texts.Scan(S);
		IF (S.class = Texts.Char) & (S.c = "^") OR (S.line > 0) THEN Oberon.GetSelection(text, beg, end, time);
			IF time >= 0 THEN Texts.OpenScanner(S, text, beg); Texts.Scan(S) END
		END;
		IF (time >= 0) & (S.class = Texts.Name) THEN i := 0;
			WHILE (S.s[i] # 0X) & (S.s[i] # ".") DO name[i] := S.s[i]; INC(i) END;
			IF i < Modules.ModNameLen THEN
				name[i] := "."; name[i+1] := "M"; name[i+2] := "o"; name[i+3] := "d"; name[i+4] := 0X;
				find.len := 0; j := i + 1; 
				WHILE S.s[j] # 0X DO find.buf[find.len] := S.s[j]; INC(find.len); INC(j) END;
				find.buf[find.len] := 0FFX; INC(find.len);
				find.time := time;
				text := TextFrames.Text(name);
				Find(text, 0, end); IF end < 0 THEN end := 0 END;
				F := NewView(name, Texts.Name, text, end);
				IF end > 0 THEN SetCaret(F, end) END
			END
		END
	END Show;

	PROCEDURE Recall*;
		VAR B: Texts.Buffer; copyover: Oberon.CopyOverMsg;
	BEGIN Texts.Recall(B);
		IF B # NIL THEN copyover.beg := 0; copyover.end := B.len;
			copyover.text := TextFrames.Text(""); Texts.Append(copyover.text, B);
			Oberon.FocusViewer.handle(Oberon.FocusViewer, copyover)
		END
	END Recall;

	PROCEDURE ClearReplaceBuffer*;
	BEGIN Texts.OpenBuf(repl.buf)
	END ClearReplaceBuffer;

	PROCEDURE Replace*;
		VAR F: TextFrames.Frame; T: Texts.Text; beg, end: LONGINT;
	BEGIN F := TargetFrame(); SetReplBuf;
		IF (F # NIL) & F.hasCar THEN T := F.text; end := F.carloc.pos; beg := end - find.len;
			TextFrames.RemoveSelection(F);
			IF Check(T, beg) THEN Subst(T, beg, end) END;
			Find(T, end, beg);
			IF beg >= 0 THEN ShowPos(F, beg); SetCaret(F, beg)
			ELSE TextFrames.RemoveCaret(F)
			END
		END
	END Replace;

	PROCEDURE ReplaceAll*;
		VAR F: TextFrames.Frame; T: Texts.Text; beg, end: LONGINT;
	BEGIN F := TargetFrame(); SetReplBuf;
		IF (F # NIL) & F.hasCar THEN T := F.text; end := F.carloc.pos; beg := end - find.len;
			TextFrames.RemoveSelection(F);
			IF Check(T, beg) THEN Subst(T, beg, end) END;
			LOOP Find(T, end, beg);
				IF beg < 0 THEN EXIT END;
				Subst(T, beg - find.len, end)
			END
		END
	END ReplaceAll;

	PROCEDURE ChangeFont*;
	BEGIN Change({0})
	END ChangeFont;

	PROCEDURE ChangeColor*;
	BEGIN Change({1})
	END ChangeColor;

	PROCEDURE ChangeOffset*;
	BEGIN Change({2})
	END ChangeOffset;

	PROCEDURE ChangeBackgroundColor*;
		VAR F: TextFrames.Frame; m: MenuViewers.ModifyMsg; S: Texts.Scanner; H: INTEGER;
	BEGIN F := MarkedFrame();
		IF F # NIL THEN GetArg(S);
			IF S.class = Texts.Int THEN
				F.col := SHORT(SHORT(S.i)); m.id := MenuViewers.extend; m.Y := F.Y; H := F.H;
				m.H := 0; F.handle(F, m); (*suspend*)
				m.H := H; F.handle(F, m) (*extend*)
			END
		END
	END ChangeBackgroundColor;


	PROCEDURE InsertParc*;
		VAR copy: Texts.CopyMsg; insert: TextFrames.InsertElemMsg;
	BEGIN
		TextFrames.defParc.handle(TextFrames.defParc, copy); insert.e := copy.e;
		Oberon.FocusViewer.handle(Oberon.FocusViewer, insert)
	END InsertParc;

	PROCEDURE Parcs*;
		VAR S: Texts.Scanner; V: Viewers.Viewer; F: TextFrames.Frame; um: TextFrames.UpdateMsg;
			end: LONGINT; R: Texts.Reader;
	BEGIN
		IF Oberon.Par.frame # Oberon.Par.vwr.dsc THEN Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
			Texts.Scan(S);
			IF (S.class = Texts.Char) & (S.line = 0) & (S.c = "*") THEN V := Oberon.MarkedViewer() ELSE V := NIL END
		ELSE V := Oberon.Par.vwr
		END;
		IF (V # NIL) & (V IS MenuViewers.Viewer) & (V.dsc.next IS TextFrames.Frame) THEN
			F := V.dsc.next(TextFrames.Frame); F.showsParcs := ~ F.showsParcs;
			Texts.OpenReader(R, F.text, F.org); Texts.ReadElem(R); end := TextFrames.Pos(F, F.X + F.W, F.Y);
			WHILE (Texts.Pos(R) <= end) & (R.elem # NIL) & ~(R.elem IS TextFrames.Parc) DO Texts.ReadElem(R) END;
			IF (R.elem # NIL) & (R.elem IS TextFrames.Parc) & (Texts.Pos(R) <= end) THEN
				um.id := Texts.replace; um.text := F.text; um.end := end;
				um.beg := Texts.Pos(R)-1;
				F.handle(F, um)
			END
		END
	END Parcs;

	PROCEDURE Open*;
		VAR S: Texts.Scanner; F: TextFrames.Frame; end: LONGINT;
	BEGIN Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); GetMainArg(S, end);
		IF (S.class = Texts.Name) OR (S.class = Texts.String) THEN
			F := NewView(S.s, S.class, TextFrames.Text(S.s), 0);
			ShowAliens(F.text)
		END
	END Open;

	PROCEDURE Store*;
		VAR S: Texts.Scanner; R: Texts.Reader; V: Viewers.Viewer; T: Texts.Text; ch: CHAR;
	BEGIN V := NIL;
		IF Oberon.Par.frame = Oberon.Par.vwr.dsc THEN V := Oberon.Par.vwr
		ELSIF Oberon.Pointer.on THEN  V := Oberon.MarkedViewer()
		END;
		IF (V # NIL) & (V IS MenuViewers.Viewer) & (V.dsc IS TextFrames.Frame) & (V.dsc.next IS TextFrames.Frame) THEN
			Texts.OpenScanner(S, V.dsc(TextFrames.Frame).text, 0); Texts.Scan(S);
			IF (S.class = Texts.Name) OR (S.class = Texts.String) THEN
				Str("Edit.Store "); Str(S.s); T := V.dsc.next(TextFrames.Frame).text;
				Texts.Close(T, S.s); Int(T.len); Ln;
				T := V.dsc(TextFrames.Frame).text;
				Texts.OpenReader(R, T, T.len - 1); Texts.Read(R, ch);
				IF ch = "!" THEN Texts.Delete(T, T.len - 1, T.len) END
			END
		END
	END Store;

	PROCEDURE Set*;
		VAR S: Texts.Scanner; R: Texts.Reader; text: Texts.Text; P: TextFrames.Parc;
			msg: ParcElems.StateMsg; pos, beg, end, time: LONGINT;
	BEGIN GetArg(S); Oberon.GetSelection(text, beg, end, time);
		IF time >= 0 THEN Texts.OpenReader(R, text, beg); 
			REPEAT Texts.ReadElem(R); pos := Texts.Pos(R);
				IF ~R.eot & (pos <= end) & (R.elem IS TextFrames.Parc) THEN
					msg.id := ParcElems.set; msg.pos := pos - 1; msg.frame := NIL; msg.par := S; msg.log := Oberon.Log;
					P := R.elem(TextFrames.Parc); P.handle(P, msg);
				END
			UNTIL R.eot OR (pos > end)
		ELSE Str("Edit.Set failed (no parc selected)"); Ln
		END
	END Set;

	PROCEDURE Get*;
		VAR S: Texts.Scanner; R: Texts.Reader; text: Texts.Text; P: TextFrames.Parc; pos, beg, end, time: LONGINT;
			msg: ParcElems.StateMsg;
	BEGIN GetArg(S); Oberon.GetSelection(text, beg, end, time);
		IF time >= 0 THEN
			Texts.OpenReader(R, text, beg); Texts.ReadElem(R); pos := Texts.Pos(R);
			IF ~R.eot & (pos <= end) & (R.elem IS TextFrames.Parc) THEN
				Str("Edit.Set ^ ");
				msg.id := ParcElems.get; msg.pos := pos - 1; msg.frame := NIL; msg.par := S; msg.log := Oberon.Log;
				P := R.elem(TextFrames.Parc); P.handle(P, msg)
			ELSE Str("Edit.Get failed (no parc selected)")
			END
		ELSE Str("Edit.Get failed (no parc selected)")
		END;
		Ln
	END Get;


	PROCEDURE Print*;
		VAR S, S1: Texts.Scanner; V: Viewers.Viewer; F: TextFrames.Frame; end: LONGINT; draft: BOOLEAN;

		PROCEDURE PrintText(VAR S: Texts.Scanner; T: Texts.Text; name: ARRAY OF CHAR; draft: BOOLEAN);
			CONST headerLen = 128;
			VAR pos, len: LONGINT; ch: CHAR;
				hx, hy, hw, bx, by, bw, bh, i, k: INTEGER;
				nofcopies, pno, first, last, arab: INTEGER;
				fnt: Fonts.Font; label, labelfirst, alt: BOOLEAN;
				header: ARRAY headerLen OF CHAR;
		BEGIN hx := headerX; hw := headerW;
			hy := SHORT((LONG(Printer.PageHeight) * Unit - 17 * mm) DIV Unit);
			bx := bodyX; by := bodyY; bw := bodyW;
			bh := SHORT((LONG(Printer.PageHeight) * Unit - 37 * mm) DIV Unit);
			nofcopies := 1; pno := 0; first := 0; last := 10000; arab := 1;
			label := TRUE; labelfirst := TRUE; alt := FALSE;
			header[0] := 0X; fnt := Fonts.Default;
			Texts.Scan(S);
			WHILE (S.class = Texts.Char) & (S.c = OptionChar) DO
				Texts.Scan(S);
				IF S.class = Texts.Name THEN ch := CAP(S.s[0]);
					IF ch # "H" THEN Texts.Scan(S) END;
					IF ch = "A" THEN alt := TRUE
					ELSIF (ch = "C") & (S.class = Texts.Int) & (1 <= S.i) & (S.i < 10) THEN nofcopies := SHORT(S.i); Texts.Scan(S)
					ELSIF (ch = "F") & (S.class = Texts.Name) THEN fnt := Fonts.This(S.s); Texts.Scan(S)
					ELSIF ch = "H" THEN
						REPEAT Texts.Read(S, ch) UNTIL (ch > " ") OR S.eot;
						IF ch = 22X THEN i := 0; (* read string *)
							REPEAT Texts.Read(S, ch); header[i] := ch; INC(i) UNTIL (ch = 22X) OR (ch = CR);
							header[i-1] := 0X; Texts.Read(S, ch);
							(*COPY(S.s, header); Texts.Scan(S)*)
						ELSE COPY(name, header); AppendDate(header)
						END;
						S.nextCh := ch; Texts.Scan(S);
					ELSIF ch = "M" THEN	(*margin options*)
						IF S.class = Texts.Name THEN ch := CAP(S.s[0]); Texts.Scan(S); i := 0;
							WHILE (S.class = Texts.Int) & (0 <= S.i) DO
								k := SHORT(S.i * Scale DIV TextPrinter.Unit); INC(i); Texts.Scan(S);
								IF ch = "H" THEN
									IF i = 1 THEN hx := k ELSIF i = 2 THEN hy := k ELSIF i = 3 THEN hw := k END
								ELSIF ch = "B" THEN
									IF i = 1 THEN bx := k ELSIF i = 2 THEN by := k
									ELSIF i = 3 THEN bw := k ELSIF i = 4 THEN bh := k
									END
								END
							END
						END
					ELSIF ch = "P" THEN	(*page numbering options*)
						IF (S.class = Texts.Int) & (0 <= S.i) THEN pno := SHORT(S.i); first := pno; Texts.Scan(S)
						ELSIF S.class = Texts.Name THEN ch := CAP(S.s[0]); Texts.Scan(S);
							IF ch = "F" THEN labelfirst := FALSE
							ELSIF ch = "N" THEN label := FALSE
							ELSIF ch = "R" THEN arab := -1;
								IF first = 0 THEN pno := 1; first := 1 END
							END
						END
					ELSIF (ch = "S") & (S.class = Texts.Int) & (0 <= S.i) THEN first := SHORT(S.i); Texts.Scan(S);
						IF (S.class = Texts.Int) & (0 <= S.i) THEN last := SHORT(S.i); Texts.Scan(S) ELSE last := first END
					END
				END
			END;
			Ch(" "); Str(name); Int(nofcopies); Ch(" ");
			IF draft THEN TextPrinter.PrintDraft(T, name, nofcopies)
			ELSE pos := 0; len := T.len;
				WHILE (pos < len) & (pno <= last) & (Printer.res = 0) DO
					IF (first <= pno) & label & labelfirst THEN
						TextPrinter.PlaceHeader(hx, hy, hw, arab*pno, fnt, header, alt)
					END;
					TextPrinter.PlaceBody(bx, by, bw, bh, T, pos, pno, (first <= pno) & (pno <= last));
					IF first <= pno THEN Printer.Page(nofcopies); Ch(".") ELSE Ch("'") END;
					INC(pno); labelfirst := TRUE
				END
			END;
			Ln
		END PrintText;

	BEGIN Str("Edit.Print "); Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
		IF ((S.class = Texts.Name) OR (S.class = Texts.String)) & (S.line = 0) THEN Str(S.s);
			Printer.Open(S.s, Oberon.User, Oberon.Password); TextPrinter.InitFonts;
			IF Printer.res = 0 THEN GetMainArg(S, end);
				IF (S.class = Texts.Char) & (S.c = "%") THEN draft := TRUE; Texts.Scan(S) ELSE draft := FALSE END;
				IF Oberon.Par.frame = Oberon.Par.vwr.dsc THEN
					F := Oberon.Par.frame(TextFrames.Frame);
					IF (F.next # NIL) & (F.next IS TextFrames.Frame) THEN
						Texts.OpenScanner(S1, F.text, 0); Texts.Scan(S1);
						PrintText(S, F.next(TextFrames.Frame).text, S1.s, draft)
					END
				ELSIF (S.class = Texts.Char) & (S.c = "*") THEN V := Oberon.MarkedViewer();
					IF (V IS MenuViewers.Viewer) & (V.dsc.next IS TextFrames.Frame) THEN
						Texts.OpenScanner(S1, V.dsc(TextFrames.Frame).text, 0); Texts.Scan(S1);
						IF S1.class # Texts.Name THEN S1.s[0] := "*"; S1.s[1] := 0X END;
						PrintText(S, V.dsc.next(TextFrames.Frame).text, S1.s, draft)
					ELSE Str(" failed (bad * marker)"); Ln
					END
				ELSIF S.class = Texts.Name THEN
					REPEAT PrintText(S, TextFrames.Text(S.s), S.s, draft)
					UNTIL S.eot OR (S.class # Texts.Name) OR (Texts.Pos(S) > end)
				ELSE Ln
				END;
				Printer.Close
			ELSE Str(" failed (");
				IF Printer.res = 1 THEN Str("no such printer)")
				ELSIF Printer.res = 2 THEN Str("no link)")
				ELSIF Printer.res = 3 THEN Str("printer not ready)")
				ELSIF Printer.res = 4 THEN Str("no permission)")
				ELSE Str("res ="); Int(Printer.res); Str(" ?)")
				END;
				Ln
			END
		ELSE Str("failed (no printer specified)"); Ln
		END
	END Print;

BEGIN Texts.OpenWriter(W);
	mnam := "JanFebMarAprMayJunJulAugSepOctNovDec";
	find.time := -1; find.len := 0;
	repl.time := -1; NEW(repl.buf); Texts.OpenBuf(repl.buf)
END Edit.
