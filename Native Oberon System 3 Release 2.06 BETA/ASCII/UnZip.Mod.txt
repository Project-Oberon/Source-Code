(*$C OBERON System 3, version 2.0.

Copyright 1996 Team of the Institute of Computer Systems of ETH Zurich, ETH Center, CH-8092 Zurich,
e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon System 3 license contract.
The full text can be downloaded from ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/License.Text
or requested from the above mentioned address.

Under the license terms dated it is in particular (a) prohibited to modify the interface of this module
in any way that disagrees with style or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE UnZip;
	IMPORT SYSTEM, Files, Objects, Strings, Display, Texts, Oberon, Attributes, Gadgets, TextGadgets, Documents,
		TextDocs, Desktops;

	CONST
		MaxBuffer = 16384;

	TYPE
		Node = POINTER TO NodeDesc;
		NodeDesc = RECORD
			zero, one: Node;
			val: INTEGER;
		END;
		Code = RECORD
			val: LONGINT;
			len: INTEGER
		END;
		FileHeader = RECORD
			madeby, version, flag, method, time, date: INTEGER;
			crc32, compsize, uncompsize: LONGINT;
			namel, extral, commentl, disk, intattr: INTEGER;
			extattr, offset: LONGINT;
			fname: ARRAY 256 OF CHAR
		END;
							
		Entry* = POINTER TO EntryDesc;
		EntryDesc* = RECORD
			name*: ARRAY 256 OF CHAR;
			compsize*, uncompsize*: LONGINT;
			time*, date*, method*: INTEGER;
			next*: Entry;
			offsetdir: LONGINT;	(* offset in central dir *)
			offsetlocal: LONGINT;	(* offset del file header *)
			unsupp: INTEGER	(* is 0 only if Entry can be expanded *)
		END;

		Archive* = POINTER TO ArchiveDesc;
		ArchiveDesc* = RECORD
			File: Files.File;
			nofentries*: INTEGER;
			firstentry*: Entry
		END;
				
	VAR
		W: Texts.Writer;
		fname:ARRAY 256 OF CHAR;
		r1,r2:Files.Rider;
		F1,F2:Files.File;
		bufpos,uncompsize:LONGINT; 
		Buffer:ARRAY MaxBuffer OF CHAR;
		Dictionary: ARRAY 32*1024 OF CHAR;
		dictpos,dictsize:INTEGER;  (* pos,size in Dictionary *)
		cycled,done,note:BOOLEAN; 		
		Posinbyte:INTEGER;
		Sequence:ARRAY 19 OF INTEGER;

PROCEDURE Init;
BEGIN
	note:=FALSE;
	dictpos:=0;bufpos:=0;
	Posinbyte:=0;
	cycled:=FALSE;
	done:=FALSE
END Init;

PROCEDURE Copy(unsize:LONGINT);
VAR counter:LONGINT;
BEGIN
	F2:=Files.New(fname);
	Files.Set(r2,F2,0);
	counter:=unsize;
	WHILE counter>0 DO 
		Files.ReadBytes(r1,Buffer,MaxBuffer);
		counter:=counter-MaxBuffer;
		IF counter<0 THEN counter:=0 END;
		Files.WriteBytes(r2,Buffer,counter)
	END;
	Files.Register(F2);
	Files.Close(F2);
END Copy;

PROCEDURE ReadBuffer;  (* Read Buffer from File *)
BEGIN 
	Files.ReadBytes(r1,Buffer,MaxBuffer);
	bufpos:=0;
END ReadBuffer;

PROCEDURE ReadBitsBuffer(n:INTEGER):LONGINT;  
(* Read n Bits from Buffer = from File *)
VAR data:CHAR;
		out,restdata,restsize:INTEGER;
BEGIN 
	data:=Buffer[bufpos];
	out:=ORD(data); 
	out:=SYSTEM.LSH(out,(16-n-Posinbyte));
	out:=SYSTEM.LSH(out,(n-16));
	IF (8-Posinbyte)<n THEN	
		restsize:=n-(8-Posinbyte); 
		Posinbyte:=0;			
		INC(bufpos);
		IF bufpos=MaxBuffer THEN ReadBuffer() END;
		data:=Buffer[bufpos];
		restdata:=ORD(data);
		restdata:=SYSTEM.LSH(restdata,16-restsize);
		restdata:=SYSTEM.LSH(restdata,n-16);			
		out:=out+restdata;
		Posinbyte:=restsize;
	ELSE
		Posinbyte:=(Posinbyte+n) MOD 8;
		IF Posinbyte=0 THEN INC(bufpos) END;
	END;
	IF bufpos=MaxBuffer THEN ReadBuffer() END;
	RETURN out
END ReadBitsBuffer;

PROCEDURE InsertDict(data:CHAR);
(* Insert data in Dictionary *)
BEGIN
	IF ~cycled & (dictpos=dictsize-1) THEN cycled:=TRUE END;
	Dictionary[dictpos]:=data;
	dictpos:=(dictpos+1) MOD dictsize;
END InsertDict;		
		
PROCEDURE ReadDict(Distance,Length:INTEGER);
(* Read LENGTH Bytes at Distance DISTANCE in Dictionary= Output Stream*)
VAR position:INTEGER;
		i:INTEGER;											
BEGIN
	i:=0;
	position:=dictpos-Distance;
	IF  ~cycled & (position < 0) THEN
		WHILE position<0 DO
				InsertDict(CHR(0));
				INC(position);
				Files.Write(r2,CHR(0));
		END;
	ELSE
		position:=position MOD dictsize;
		WHILE i<Length DO
			Files.Write(r2,Dictionary[position]);
			IF Files.Pos(r2)=uncompsize THEN done:=TRUE END;
			InsertDict(Dictionary[position]);
			position:=(position+1) MOD dictsize;
			INC(i);
		END;
	END; 
END ReadDict;	
			

PROCEDURE BuildCode (VAR Codes:ARRAY OF Code; NofCodes:INTEGER;flag:INTEGER):Node;
		(* Build Code (Codes.val) with Codes.Len and return root of tree *)	
		(* 0=Implode 1=Deflate *) 
		
VAR i,j:INTEGER;
		this:LONGINT;
		n,cur,root:Node; 
		MyCode:LONGINT;
		blcount,nextcode:ARRAY 300 OF LONGINT;
		len,bits,maxbits:INTEGER;
		last,inc:INTEGER; 
		Implode,double:BOOLEAN;
BEGIN
	Implode:=FALSE;
	IF flag=0 THEN Implode:=TRUE; END;
	maxbits:=0;
	FOR i:=0 TO NofCodes-1 DO blcount[i]:=0 END;
	FOR i:=0 TO NofCodes-1 DO
		INC(blcount[Codes[i].len]);
		IF Codes[i].len> maxbits THEN maxbits:=Codes[i].len END;
	END;
	MyCode:=0;
	FOR bits:=1 TO maxbits DO
		MyCode:=(MyCode+blcount[bits-1])*2;
		nextcode[bits]:=MyCode;
	END;
	FOR i:=0 TO NofCodes-1 DO
		len:=Codes[i].len;
		IF len#0 THEN 
							Codes[i].val:=nextcode[len];
							INC(nextcode[len])
		ELSE
			Codes[i].val:=-1;
		END;
	END;	
	(*  Codes.val is code to be inserted in tree *)
	
last:=5;
inc:=2;
double:=TRUE;
NEW(n);
n.zero:=NIL;n.one:=NIL;n.val:=-1;
root:=n;
 FOR i:=0 TO NofCodes-1 DO
	n:=root;
	j:=0;
	this:=Codes[i].val;					
	IF this#-1 THEN	
		WHILE j<Codes[i].len DO			
 			IF   (Implode & ~SYSTEM.BIT(SYSTEM.ADR(this),Codes[i].len-j-1))
 				OR
 				(~Implode & SYSTEM.BIT(SYSTEM.ADR(this),Codes[i].len-j-1))
 	 		THEN 
						IF n.one=NIL THEN
									NEW(cur);
									cur.one:=NIL;
									cur.zero:=NIL;
									cur.val:=-1;
									n.one:=cur;
									n:=cur;
						ELSE
									n:=n.one
						END;						
				ELSE
						IF n.zero=NIL THEN								
									NEW(cur);
									cur.zero:=NIL;
									cur.one:=NIL;
									cur.val:=-1;
									n.zero:=cur;
									n:=cur;
							ELSE
									n:=n.zero
							END
				END;
				INC(j);
			END; (*WHILE*)
		 	cur.val:=i	
	END
END; (* FOR *)
RETURN root						
END BuildCode;

PROCEDURE Implode(flags:INTEGER;unsize:LONGINT): INTEGER;
VAR  toMe:SHORTINT;
		nofCodes,lengthofThis,nofThis:INTEGER;
		i,j,k,l:INTEGER;
		lung,data:CHAR;
		nofTrees,minMatch:INTEGER;
		lowDist:INTEGER;
		Distance,Length:INTEGER;
		LiteralTree,LengthTree,DistanceTree,cur:Node;
		bit:LONGINT;
		res:CHAR;
		byte:CHAR;
		literal:LONGINT;
		Codes:ARRAY 256 OF Code;
BEGIN
uncompsize:=unsize; 
  IF ODD(flags DIV 2) THEN 
	dictsize:=8*1024
ELSE
	dictsize:=4*1024
END;

IF ODD(flags DIV 4) THEN
	nofTrees:=3;
	minMatch:=3
ELSE
	nofTrees:=2;
	minMatch:=2
END; 
 
 FOR l:=nofTrees TO 1 BY -1 DO
 	k:=0;
 	Files.Read(r1,lung); 
 	nofCodes:=ORD(lung);
 	FOR i:=0 TO nofCodes  DO
		Files.Read(r1,data);
		lengthofThis:=(ORD(data) MOD 16)+1;
		nofThis:=(ORD(data) DIV 16)+1;	
		FOR j:=1 TO nofThis DO
				Codes[k].len:=lengthofThis;
				INC(k)
		END;
 	END;
	CASE l OF
		|3: LiteralTree:=BuildCode(Codes,k,0);
		|2: LengthTree:=BuildCode(Codes,k,0);
		|1:DistanceTree:=BuildCode(Codes,k,0);
	END	 	
 END;
 
(* Begin Decoding *)
  
F2:=Files.New(fname);
Files.Set(r2,F2,0);
ReadBuffer();
LOOP  
 IF done THEN EXIT END;
 literal:=ReadBitsBuffer(1);	
 IF literal=1 THEN
		IF nofTrees=3 THEN
			cur:=LiteralTree;
			WHILE cur.val=-1 DO
				bit:=ReadBitsBuffer(1);	
				IF bit=1 THEN
						IF cur.one#NIL THEN
							cur:=cur.one
						ELSE 
							(*Out.String("FILE CORRUPTED");HALT(99)*)
							RETURN 10 
						END;
				ELSE
						IF cur.zero#NIL THEN
							cur:=cur.zero 
						ELSE
							(*Out.String("FILE CORRUPTED");HALT(99)*)
							RETURN 10
						END;
				END;
			END;
			res:=CHR(cur.val);
		ELSE  
				res:=CHR(SHORT(ReadBitsBuffer(8)))	
		END;	
		Files.Write(r2,res);
		IF Files.Pos(r2)=uncompsize THEN done:=TRUE END;
		InsertDict(res); 

	ELSE (* not literal *) 

		(* read lower 6 or 7 bits of distance offset*)
		IF dictsize=8*1024 THEN toMe:=6 ELSE toMe:=5 END;
		lowDist:=0;
		FOR i:=0 TO toMe DO
				bit:=ReadBitsBuffer(1);
				lowDist:=lowDist+SYSTEM.LSH(SHORT(bit),i);
		END;
		
			(* read and decode upper 6 bits *);

	cur:=DistanceTree;
		WHILE cur.val=-1 DO
			bit:=ReadBitsBuffer(1);	
			IF bit=1 THEN
				IF cur.one=NIL THEN 
  	     	 	(*Out.String("FILE CORRUPTED");HALT(99)*)
  	     	 	RETURN 10 
				ELSE
		   		cur:=cur.one
				END;
			ELSE
				IF cur.zero=NIL THEN 
		  		(*Out.String("FILE CORRUPTED");HALT(99)*)
  	     	 	RETURN 10 
				ELSE
	 			cur:=cur.zero
				END;
			END
		END;

		IF dictsize=8*1024 THEN 
				Distance:=SYSTEM.LSH(cur.val,7)+lowDist;
		ELSE
				Distance:=SYSTEM.LSH(cur.val,6)+lowDist;
		END;
			(*read and decode Length Value *);
			
		cur:=LengthTree;
		WHILE cur.val=-1 DO
			bit:=ReadBitsBuffer(1);	
			IF bit=1 THEN
				IF cur.one=NIL THEN 
        		 (*Out.String("FILE CORRUPTED");HALT(99)*)
  	     	 	RETURN 10
				ELSE
	   			cur:=cur.one
				END;
			ELSE
				IF cur.zero=NIL THEN 
	  			(*Out.String("FILE CORRUPTED");HALT(99)*)
  	     	 	RETURN 10 
				ELSE
	 			cur:=cur.zero
				END;
			END;
		END;
		Length:=cur.val;

	Length:=Length+minMatch;

	IF Length=63+minMatch	THEN
		byte:=CHR(ReadBitsBuffer(8)); 
		Length:=Length+ORD(byte);
	END;
	ReadDict(Distance+1,Length);
	END;
END;
Files.Register(F2); Files.Close(F2);
RETURN 0
END Implode;


PROCEDURE MakeCodesDynHuff(VAR Codes:ARRAY OF Code;
						nofCodeLengths:INTEGER;CodeTree:Node): INTEGER;

(* Build Codes.len with CodeTree *)

VAR k,l:INTEGER;
		cur:Node;
		bit:LONGINT;
		code:LONGINT;
		times:INTEGER;
		lastcodelength:LONGINT;
BEGIN
k:=0;
WHILE k<nofCodeLengths DO
	cur:=CodeTree;
		WHILE cur.val=-1 DO
			bit:=ReadBitsBuffer(1);
			IF bit=1 THEN
				IF cur.one=NIL THEN 
  	     	 	(*Out.String("FILE CORRUPTED");HALT(99)*)
  	     	 	RETURN 10 
				ELSE
		   		cur:=cur.one
				END;
			ELSE
				IF cur.zero=NIL THEN 
		  		(*Out.String("FILE CORRUPTED");HALT(99)*)
  	     	 	RETURN 10
				ELSE
	 			cur:=cur.zero
				END;
			END
		END; (* WHILE *)
		
		code:=cur.val;
		IF (0<=code) & (code <=15) THEN 
						Codes[k].len:=SHORT(code);
						lastcodelength:=code;k:=k+1;
		ELSIF code=16 THEN
				 times:=SHORT(ReadBitsBuffer(2)); 
				 FOR l:=1 TO times+3 DO
				 	Codes[k].len:=SHORT(lastcodelength);
					 	k:=k+1;
				 END;
		ELSIF code=17 THEN 
				times:=SHORT(ReadBitsBuffer(3)); 
				FOR l:=1 TO times+3 DO
					Codes[k].len:=0;
				 	k:=k+1;
				 END;
		ELSIF code=18 THEN 
				times:=SHORT(ReadBitsBuffer(7));
				FOR l:=1 TO times+11 DO
					Codes[k].len:=0;
				 	k:=k+1;
				 END;
		ELSE (*HALT(100)*) RETURN 10			(* Invalid Length Code *)
		END (* IF *)
END; (* WHILE *)
RETURN 0
END MakeCodesDynHuff;

PROCEDURE DynamicHuff(VAR LitTree,DistTree:Node): INTEGER;
VAR HLIT,HDLIST,HCLEN:INTEGER;
		Codes:ARRAY 300 OF Code;
		CodeTree:Node; 
		nofCodes:INTEGER;	
		res, i:INTEGER;
BEGIN
	HLIT:=SHORT(ReadBitsBuffer(5))+257;
	HDLIST:=SHORT(ReadBitsBuffer(5))+1;
	HCLEN:=SHORT(ReadBitsBuffer(4))+4;
	
	FOR i:=0 TO HCLEN-1 DO
		Codes[Sequence[i]].len:=SHORT(ReadBitsBuffer(3))
	END;
	FOR i:=HCLEN TO 18 DO			(* Others Codes.Length = 0 *)
		Codes[Sequence[i]].len:=0
	END;

(* Build Codes Code *)
nofCodes:=19;
CodeTree:=BuildCode(Codes,nofCodes,1);

(* Build input for Literal/Length Tree *)
res := MakeCodesDynHuff(Codes,HLIT,CodeTree);
IF res # 0 THEN RETURN res END;

(* Build Literal/Length Tree *)
nofCodes:=HLIT;
LitTree:=BuildCode(Codes,nofCodes,1);

(* Build input for Distance Tree *)
res := MakeCodesDynHuff(Codes,HDLIST,CodeTree);
IF res # 0 THEN RETURN res END;

(* Build Distance Tree *)
nofCodes:=HDLIST;
DistTree:=BuildCode(Codes,nofCodes,1);
RETURN 0
END DynamicHuff;

PROCEDURE Deflate(Flags:INTEGER;unsize:LONGINT): INTEGER;
VAR Codes:ARRAY 300 OF Code;
		cur:Node;
		value:CHAR;
		bit:LONGINT;
		Distance,Length:LONGINT;
		dummy,data:LONGINT;
		res, i:INTEGER;
		last:BOOLEAN;
		DistanceTreeFix,LiteralTreeFix,DistTree,LitTree:Node;
		blockl,blocklcompl:LONGINT;
BEGIN
uncompsize:=unsize;
dictsize:=-32768;
FOR i:=0 TO 143 DO	Codes[i].len:=8 END;
FOR i:=144 TO 255 DO	Codes[i].len:=9  END;
FOR i:=256 TO 279 DO	Codes[i].len:=7  END;
FOR i:=280 TO 287 DO	Codes[i].len:=8  END;

LiteralTreeFix:=BuildCode(Codes,i,1);

FOR i:=0 TO 31 DO Codes[i].len:=5 END;
		
DistanceTreeFix:=BuildCode(Codes,i,2);
F2:=Files.New(fname);
 Files.Set(r2,F2,0);
ReadBuffer;
last:=FALSE; 
WHILE ~last DO 
	data:=ReadBitsBuffer(1);
	IF data=1 THEN last:=TRUE END;
	data:=ReadBitsBuffer(2);
	IF data=0 THEN 
			dummy:=ReadBitsBuffer(5);  (* skip *)
			data:=ReadBitsBuffer(8);
			blockl:=ReadBitsBuffer(8)+256*data;
			data:=ReadBitsBuffer(8);
			blocklcompl:=ReadBitsBuffer(8)+256*data;
			WHILE blockl>0 DO
				DEC(blockl);
				data:=ReadBitsBuffer(8);
				InsertDict(CHR(data));
				Files.Write(r2,CHR(data))
			END;			
	ELSIF data # 3 THEN
			IF data=2 THEN
					 res := DynamicHuff(LitTree,DistTree);
					 IF res # 0 THEN RETURN res END
			ELSE 
				(* data=1 Fixed Huffman *);  
				LitTree:=LiteralTreeFix;
				DistTree:=DistanceTreeFix;
			END;
			
			LOOP 
				cur:=LitTree;
				WHILE cur.val=-1 DO
					bit:=ReadBitsBuffer(1);	
						IF bit=1 THEN
							IF cur.one=NIL THEN 
								(*Out.String("FILE CORRUPTED");HALT(99)*)
								RETURN 10
							ELSE
								cur:=cur.one
							END;
					ELSE
							IF cur.zero=NIL THEN 
								(*Out.String("FILE CORRUPTED");HALT(99)*)
								RETURN 10
							ELSE
								cur:=cur.zero
							END;
					END;
				END;  (* WHILE *)
				IF cur.val < 256 THEN
						value:=CHR(cur.val);
						Files.Write(r2,value);
						InsertDict(value);
				ELSIF cur.val=256 THEN EXIT 
				ELSE	(* value = 257...285*)
						Length:=cur.val;
						CASE Length OF
							|257..264:Length:=Length-254; (* DO NOTHING *)
							|265..268:Length:=(Length-265)*2+11+ReadBitsBuffer(1)
							|269..272:Length:=(Length-269)*4+19+ReadBitsBuffer(2)
							|273..276:Length:=(Length-273)*8+35+ReadBitsBuffer(3);
							|277..280:Length:=(Length-277)*16+67+ReadBitsBuffer(4)
							|281..284:Length:=(Length-281)*32+131+ReadBitsBuffer(5)
							|285:Length:=258
							ELSE
								HALT(100)
						END; (* CASE *)
							
					cur:=DistTree;
						WHILE cur.val=-1 DO
							bit:=ReadBitsBuffer(1);	
							IF bit=1 THEN
								IF cur.one=NIL THEN 
									(*Out.String("FILE CORRUPTED");HALT(99)*)
									RETURN 10
								ELSE
									cur:=cur.one
								END;
							ELSE
								IF cur.zero=NIL THEN 
									(*Out.String("FILE CORRUPTED");HALT(99)*)
									RETURN 10 
								ELSE
									cur:=cur.zero
								END;
							END;
						END;(* WHILE *)
						Distance:=cur.val;
						CASE Distance OF
						|0..3:Distance:=cur.val+1
						|4..5:Distance:=5+(Distance-4)*2+ReadBitsBuffer(1)
						|6..7:Distance:=9+(Distance-6)*4+ReadBitsBuffer(2)
						|8..9:Distance:=17+(Distance-8)*8+ReadBitsBuffer(3)
						|10..11:Distance:=33+(Distance-10)*16+ReadBitsBuffer(4)
						|12..13:Distance:=65+(Distance-12)*32+ReadBitsBuffer(5)
						|14..15:Distance:=129+(Distance-14)*64+ReadBitsBuffer(6)
						|16..17:Distance:=257+(Distance-16)*128+ReadBitsBuffer(7)
						|18..19:Distance:=513+(Distance-18)*256+ReadBitsBuffer(8)
					|20..21:Distance:=1025+(Distance-20)*512+ReadBitsBuffer(8)+
												256*ReadBitsBuffer(1);
												
					|22..23:Distance:=2049+(Distance-22)*1024+ReadBitsBuffer(8)+
													256*ReadBitsBuffer(2);
					|24..25:Distance:=4097+(Distance-24)*2048+ReadBitsBuffer(8)+
													256*ReadBitsBuffer(3);
					|26..27:Distance:=8193+(Distance-26)*4096+ReadBitsBuffer(8)+
													256*ReadBitsBuffer(4);
					|28..29:Distance:=16385+(Distance-28)*8192+ReadBitsBuffer(8)+
													256*ReadBitsBuffer(5);
						ELSE
							HALT(99)
						END; (* CASE *)
						
						 ReadDict(SHORT(Distance),SHORT(Length)); 
						 
				END; (* IF*)
			END (* LOOP *)
	ELSE 
		HALT(99)
	END;
END;
Files.Register(F2); Files.Close(F2);
RETURN 0
END Deflate;

PROCEDURE ReadFileHeader(VAR header:FileHeader;r1:Files.Rider);
BEGIN
	Files.ReadInt(r1,header.madeby);
	Files.ReadInt(r1,header.version);
	Files.ReadInt(r1,header.flag);
	Files.ReadInt(r1,header.method);
	Files.ReadInt(r1,header.time);
	Files.ReadInt(r1,header.date);
	Files.ReadLInt(r1,header.crc32);
	Files.ReadLInt(r1,header.compsize);
	Files.ReadLInt(r1,header.uncompsize);
	Files.ReadInt(r1,header.namel);
	Files.ReadInt(r1,header.extral);
	Files.ReadInt(r1,header.commentl);
	Files.ReadInt(r1,header.disk);
	Files.ReadInt(r1,header.intattr);
	Files.ReadLInt(r1,header.extattr);
	Files.ReadLInt(r1,header.offset);
	Files.ReadBytes(r1,header.fname,header.namel);
	header.fname[header.namel]:=0X;
END ReadFileHeader;


PROCEDURE OpenArchive*(name: ARRAY OF CHAR;VAR res: INTEGER): Archive;
(* res=1=File not found    res=2=not a valid zip file *)
VAR dummy:INTEGER;
		sig:LONGINT;
		F1:Files.File;
		r1:Files.Rider;
		ThisArchive:Archive;
		header:FileHeader;
		first:BOOLEAN;
		NewEntry,ActEntry:Entry;

BEGIN   
	sig:=0;
	first:=TRUE;
	res:=99;
	F1:=Files.Old(name);
	IF F1 # NIL THEN 
			Files.Set(r1,F1,Files.Length(F1)-17);
			WHILE (sig#06054B50H) & (Files.Pos(r1)#4) DO
				Files.Set(r1,F1,Files.Pos(r1)-5); 
				 Files.ReadLInt(r1,sig);			
			END;
			IF sig=06054B50H THEN
				Files.ReadInt(r1,dummy);
				Files.ReadInt(r1,dummy);
				Files.ReadInt(r1,dummy);
				NEW(ThisArchive);
				Files.ReadInt(r1,ThisArchive.nofentries);
				ThisArchive.File:=F1;
				ThisArchive.firstentry:=NIL;
				NEW(ActEntry);		
				LOOP 
					sig:=0;
					WHILE (sig#02014B50H) & (sig#04034B50H) & (Files.Pos(r1)#4) DO
						Files.Set(r1,F1,Files.Pos(r1)-5);
						Files.ReadLInt(r1,sig);
					END; (* WHILE *)
					IF sig=04034B50H THEN 
						IF first THEN
								res:=3;
						ELSE
								res:=0;
						END;
						 EXIT 
					ELSIF sig#02014B50H THEN
							res:=3
					END;	
					IF first THEN first:=FALSE END;				
					ReadFileHeader(header,r1);
					NEW(NewEntry);
					NewEntry.next:=NIL;
					NewEntry.offsetdir:=Files.Pos(r1)-1; (* posizione, nclusa sig *)
					NewEntry.offsetlocal:=header.offset;
					NewEntry.compsize:=header.compsize;
					NewEntry.uncompsize:=header.uncompsize;
					NewEntry.date:=header.date;
					NewEntry.time:=header.time;
					NewEntry.method:=header.method;
					IF ODD(header.flag) THEN NewEntry.unsupp:=5 END;
					IF (header.method#0) & (header.method#6) & (header.method#8) THEN
						NewEntry.unsupp:=4
					END;
					COPY(header.fname,NewEntry.name);
					IF ThisArchive.firstentry#NIL THEN
						ActEntry.next:=NewEntry;
						ActEntry:=ActEntry.next;
					ELSE
						ThisArchive.firstentry:=NewEntry;
						ActEntry:=NewEntry
					END;						
				END (*LOOP*)
		ELSE (*sig#0605..*)
			res:=3
		END
	ELSE
		res:=1
	END; (* IF *)
RETURN ThisArchive
END OpenArchive;
				
	
PROCEDURE ExtractThis*(A:Archive;E:Entry;filename:ARRAY OF CHAR; VAR res:INTEGER);		
(* res=1  file not in archive  res=2 not a valid archive *)
VAR	ldummy,compsize,sig:LONGINT;
			cdummy:CHAR;
			i,idummy,flags,method:INTEGER;
			extral,namel:INTEGER;
BEGIN
IF E.unsupp=0 THEN
	Init;
	F1:=A.File;
	IF F1#NIL THEN
		COPY(filename,fname);
		 compsize:=E.compsize;
		uncompsize:=E.uncompsize;
		Files.Set(r1,F1,E.offsetlocal);
		Files.ReadLInt(r1,sig);
		Files.ReadInt(r1,idummy);
		Files.ReadInt(r1,flags);
		flags:=flags MOD 16;
		Files.ReadInt(r1,method);Files.ReadInt(r1,idummy);
		Files.ReadInt(r1,idummy);
		Files.ReadLInt(r1,ldummy);
		Files.ReadLInt(r1,ldummy);Files.ReadLInt(r1,ldummy);
		Files.ReadInt(r1,namel);Files.ReadInt(r1,extral);
		  FOR i:=1 TO namel DO
		  	Files.Read(r1,cdummy);
		  END;
		FOR i:=0 TO extral-1 DO Files.Read(r1,cdummy) END;
		IF flags>7 THEN
			Files.ReadLInt(r1,ldummy);Files.ReadLInt(r1,ldummy);Files.ReadLInt(r1,ldummy);
		END; 
		CASE method OF		
				0: Copy(uncompsize); res:=0
			 |6: res := Implode(flags,uncompsize);
			 |8: res := Deflate(flags,uncompsize);
			ELSE
				res:=4;
		END;  (* CASE *)
 ELSE
	res:=2
 END
ELSE 
	res:=E.unsupp
END;
END ExtractThis;

	PROCEDURE Error(res: INTEGER);
	BEGIN
		CASE res OF
			0: RETURN
			|1: Texts.WriteString(W,  "Archive doesnt exist")
			|3: Texts.WriteString(W,  "Archive not valid")
			|4: Texts.WriteString(W,  "Unsupported compression method")
			|5: Texts.WriteString(W,  "Archive is encrypted")
			|10: Texts.WriteString(W,  "Archive corrupted")
			|11: Texts.WriteString(W,  "Entry not found")
		ELSE
			Texts.WriteString(W, "ERROR")
		END;
		Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)
	END Error;

	PROCEDURE do(doc, show: BOOLEAN);
		VAR
			D: Documents.Document;
			S: Attributes.Scanner;
			A: Archive;
			E: Entry;
			text: Texts.Text;
			beg, end, time: LONGINT;
			suffix, temp: ARRAY 64 OF CHAR;
			F: Files.File;
			R: Files.Rider;
			res: INTEGER;
			ch: CHAR;
	BEGIN
		A := NIL; res := MIN(INTEGER);
		Attributes.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
		Attributes.Scan(S);
		IF Desktops.IsInMenu(Gadgets.context) THEN
			D := Desktops.CurDoc(Gadgets.context);
			IF D # NIL THEN
				A := OpenArchive(D.name, res);
				text := NIL; time := -1;
				Oberon.GetSelection(text, beg, end, time);
				IF (text # NIL) & (time > 0) THEN
					Attributes.OpenScanner(S, text, beg);
					Attributes.Scan(S)
				END
			END
		ELSIF S.class IN {Attributes.Name, Attributes.String} THEN
			A := OpenArchive(S.s, res); Attributes.Scan(S)
		END;
		IF (A # NIL) & (res = 0) & (S.class IN {Attributes.Name, Attributes.String}) THEN
			E := A.firstentry;
			WHILE (E # NIL) & (E.name # S.s) DO
				E := E.next
			END;
			IF E # NIL THEN
				IF show THEN
					Strings.GetSuffix(E.name, suffix);
					temp := "TempUnZip."; Strings.Append(temp, suffix);
					ExtractThis(A, E, temp, res);
					IF doc THEN
						D := Documents.Open(temp);
						IF (D # NIL) & (D.dsc # NIL) THEN
							COPY(E.name, D.name); Desktops.ShowDoc(D)
						END
					ELSE
						NEW(text); Texts.Open(text, "");
						F := Files.Old(temp); Files.Set(R, F, 0);
						Files.Read(R, ch);
						WHILE ~R.eof DO
							IF ch # Strings.LF THEN
								Texts.Write(W, ch)
							END;
							Files.Read(R, ch)
						END;
						Texts.Append(text, W.buf);
						TextDocs.ShowText(E.name, text, Display.Width DIV 3, Display.Height DIV 2)
					END
				ELSE
					Texts.WriteString(W, "Extracting "); Texts.WriteString(W, E.name); Texts.Append(Oberon.Log, W.buf);
					ExtractThis(A, E, E.name, res);
					IF res = 0 THEN
						Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)
					END
				END
			ELSE
				res := 11
			END
		END;
		IF res > 0 THEN
			Error(res)
		END
	END do;

	PROCEDURE Open*;
	BEGIN
		do(TRUE, TRUE)
	END Open;

	PROCEDURE OpenAscii*;
	BEGIN
		do(FALSE, TRUE)
	END OpenAscii;

	PROCEDURE extract*;
	BEGIN
		do(FALSE, FALSE)
	END extract;

	PROCEDURE *DocHandler(D: Objects.Object; VAR M: Objects.ObjMsg);
	BEGIN
		WITH D: Documents.Document DO
			IF M IS Objects.AttrMsg THEN
				WITH M: Objects.AttrMsg DO
					IF M.id = Objects.get THEN
						IF M.name = "Gen" THEN
							M.class := Objects.String;
							M.s := "UnZip.NewDoc";
							M.res := 0
						ELSIF M.name = "Menu" THEN
							M.class := Objects.String;
							M.s := "UnZip.Open[Open] UnZip.OpenAscii[Ascii] UnZip.extract[Extract]";
							M.res := 0
						ELSE
							TextDocs.DocHandler(D, M)
						END
					ELSE
						TextDocs.DocHandler(D, M)
					END
				END
			ELSIF M IS Objects.LinkMsg THEN
				WITH M: Objects.LinkMsg DO
					IF M.id = Objects.get THEN
						IF M.name = "DeskMenu" THEN
							M.obj := Gadgets.CopyPublicObject("UnZip.DeskMenu", TRUE);
							M.res := 0
						ELSIF M.name = "SystemMenu" THEN
							M.obj := Gadgets.CopyPublicObject("UnZip.SystemMenu", TRUE);
							M.res := 0
						ELSIF M.name = "UserMenu" THEN
							M.obj := Gadgets.CopyPublicObject("UnZip.UserMenu", TRUE);
							M.res := 0
						ELSE
							TextDocs.DocHandler(D, M)
						END
					ELSE
						TextDocs.DocHandler(D, M)
					END
				END
			ELSE
				TextDocs.DocHandler(D, M)
			END
		END
	END DocHandler;

	PROCEDURE *LoadDoc(D: Documents.Document);
		VAR
			A: Archive;
			E: Entry;
			res: INTEGER;
	BEGIN
		A := OpenArchive(D.name, res);
		IF (A # NIL) & (A.nofentries > 0) & (res = 0) THEN
			E := A.firstentry;
			WHILE E # NIL DO
				Texts.WriteString(W, E.name); Texts.WriteLn(W);
				E := E.next
			END;
			Texts.Append(D.dsc(TextGadgets.Frame).text, W.buf)
		ELSE
			Error(res); D.dsc := NIL
		END
	END LoadDoc;

	PROCEDURE NewDoc*;
		VAR D: Objects.Object;
	BEGIN
		D := Gadgets.CreateObject("TextDocs.NewDoc");
		WITH D: Documents.Document DO
			D.Load := LoadDoc; D.Store := NIL;
			D.handle := DocHandler
		END;
		Objects.NewObj := D
	END NewDoc;

	PROCEDURE Extract*;
		VAR
			S: Attributes.Scanner;
			A: Archive;
			E: Entry;
			res: INTEGER;
	BEGIN
		Attributes.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
		Attributes.Scan(S);
		IF S.class IN {Attributes.Name, Attributes.String} THEN
			A := OpenArchive(S.s, res);
			IF (A # NIL) & (res = 0) THEN
				Attributes.Scan(S);
				WHILE S.class IN {Attributes.Name, Attributes.String} DO
					Texts.WriteString(W, S.s); Texts.Write(W, 09X);
					E := A.firstentry;
					WHILE (E # NIL) & (E.name # S.s) DO
						E := E.next
					END;
					Attributes.Scan(S);
					IF E # NIL THEN
						IF (S.class = Attributes.Char) & (S.c = "=") THEN
							Attributes.Scan(S);
							IF (S.class = Attributes.Char) & (S.c = ">") THEN
								Attributes.Scan(S)
							END;
							IF S.class IN {Attributes.Name, Attributes.String} THEN
								ExtractThis(A, E, S.s, res); Attributes.Scan(S)
							END
						ELSE
							ExtractThis(A, E, E.name, res)
						END 
					ELSE
						res := 11
					END;
					IF res > 0 THEN
						Error(res)
					ELSE
						Texts.WriteString(W, "done"); Texts.WriteLn(W)
					END
				END
			ELSE
				Error(res)			
			END;
			Texts.Append(Oberon.Log, W.buf)
		END
	END Extract;

	PROCEDURE ExtractAll*;
		VAR
			S: Attributes.Scanner;
			A: Archive;
			E: Entry;
			res: INTEGER;
	BEGIN
		Attributes.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
		Attributes.Scan(S);
		IF S.class IN {Attributes.Name, Attributes.String} THEN
			A := OpenArchive(S.s, res);
			IF (A # NIL) & (res = 0) THEN
				E := A.firstentry;
				WHILE (E # NIL) & (res = 0) DO
					Texts.WriteString(W, E.name); Texts.Append(Oberon.Log, W.buf);
					ExtractThis(A, E, E.name, res); Texts.WriteLn(W);
					E := E.next
				END;
				IF res > 0 THEN
					Error(res)
				END;
				Texts.Append(Oberon.Log, W.buf)
			ELSE
				Error(res)			
			END;
			Texts.Append(Oberon.Log, W.buf)
		END	
	END ExtractAll;

BEGIN
	Texts.OpenWriter(W);
 dictpos:=0;bufpos:=0;
 Sequence[0]:=16;Sequence[1]:=17;Sequence[2]:=18;Sequence[3]:=0;
 Sequence[4]:=8;Sequence[5]:=7;Sequence[6]:=9;Sequence[7]:=6;
 Sequence[8]:=10;Sequence[9]:=5;Sequence[10]:=11;Sequence[11]:=4;
 Sequence[12]:=12;Sequence[13]:=3;Sequence[14]:=13;Sequence[15]:=2;
Sequence[16]:=14;Sequence[17]:=1;Sequence[18]:=15;
 Posinbyte:=0;
 cycled:=FALSE;
  done:=FALSE
END UnZip.

/example.zip(UnZip.NewDoc)

UnZip.Extract /example.zip
	ReadMe.Txt => abc
	"file_id.diz" ~
