(*$C OBERON System 3, version 2.0.

Copyright 1996 Team of the Institute of Computer Systems of ETH Zurich, ETH Center, CH-8092 Zurich,
e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon System 3 license contract.
The full text can be downloaded from ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/License.Text
or requested from the above mentioned address.

Under the license terms dated it is in particular (a) prohibited to modify the interface of this module
in any way that disagrees with style or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE Display;	
(* Type: 86C805/801		*)
(* Date: 3.6.93					*)
(* Author: A. R. Disteli		*)
(* Modified for Native Oberon: muller 25.07.95 *)
(* 19.01.96  oswald  eos1 *)
(*   - CopyPattern now supports patterns wider than 32 pixels *)
(* 08.02.96 muller, ported to Native Oberon 2.05 *)

	IMPORT SYSTEM, Objects;
	
	CONST
		black* = 0; white* = 15; 
		BG* = 0; FG* = 15; (*background, foreground*)
		replace* = 0; paint* = 1; invert* = 2; (*operation modes*)
		
		remove* = 0; suspend* = 1; restore* = 2; (*ControlMsg id*)
		reduce* = 0; extend* = 1; move* = 2; (*ModifyMsg id*)
		display* = 0; state* = 1; (*ModifyMsg mode*)
		frame* = 0; area* = 1; (*DisplayMsg id*)
		contents* = 0; view* = 1; (*PrintMsg id*)
		get* = 0; set* = 1; reset* = 2; (*SelectMsg id*)
		drop* = 0; integrate* = 1; (*ConsumeMsg id*)
		
		(* S3 Constants *)
		index = 3D4H;
		data = 3D5H;
		Xpos = 20H;
		Ypos = 80H;
		Ymajor = 40H;
		advFnCtrl = 4AE8H;
		curX = 86E8H;
		curY = 82E8H;
		axStep = 8AE8H;
		diaStep = 8EE8H;
		errTerm = 92E8H;
		majAxis = 96E8H;
		minAxis = 0BEE8H;
		gpStat = 9AE8H;
		cmdReg = 9AE8H;
		shortStroke = 9EE8H;
		BGcol = 0A2E8H;
		FGcol = 0A6E8H;
		wrtMask = 0AAE8H;
		rdMask = 0AEE8H;
		BGmix = 0B6E8H;
		FGmix = 0BAE8H;
		MFcont = 0BEE8H;
		pixTrans = 0E2E8H;

		EAX = 0; ECX = 1; EDX = 2; EBX = 3; ESI = 6; EDI = 7; CC = -1; 
		carry = 0; zero = 6;

	TYPE Pattern* = LONGINT;
			PatternPtr = POINTER TO RECORD w, h, pixmap: SHORTINT END;
			List = POINTER TO ListDesc;
			ListDesc = RECORD
				next: List;
				pat: PatternPtr
			END;

			Frame* = POINTER TO FrameDesc;
			FrameDesc* = RECORD (Objects.ObjDesc)
				next*, dsc*: Frame;
				X*, Y*, W*, H*: INTEGER
			END;
  
			FrameMsg* = RECORD (Objects.ObjMsg)
				F*: Frame; (*target*)
				x*, y*, res*: INTEGER
			END;
		
			ControlMsg* = RECORD (FrameMsg)
				id*: INTEGER
			END;
		
			ModifyMsg* = RECORD (FrameMsg)
				id*, mode*: INTEGER;
				dX*, dY*, dW*, dH*: INTEGER;
				X*, Y*, W*, H*: INTEGER
			END;
		
			DisplayMsg* = RECORD (FrameMsg)
				id*: INTEGER;
				u*, v*, w*, h*: INTEGER
			END;
		
			PrintMsg* = RECORD (FrameMsg)
				id*, pageno*: INTEGER
			END;

			LocateMsg* = RECORD (FrameMsg)
				loc*: Frame;
				X*, Y*, u*, v*: INTEGER
			END;
		
			SelectMsg* = RECORD (FrameMsg)
				id*: INTEGER;
				time*: LONGINT;
				sel*: Frame;
				obj*: Objects.Object
			END;
		
			ConsumeMsg* = RECORD (FrameMsg)
				id*: INTEGER;
				u*, v*: INTEGER;
				obj*: Objects.Object
			END;
		
			MsgProc* = PROCEDURE (VAR M: FrameMsg);

	VAR
		Unit*: LONGINT; (* RasterUnit = Unit/36000 mm *)
		Left*, (* left margin of black-and-white maps *)
		ColLeft*, (* left margin of color maps *)
		Bottom*, (* bottom of primary map *)
		UBottom*, (* bottom of secondary map *)
		Width*, (* map width *)
		Height*: (* map hight*)
			INTEGER;
			
		arrow*, star*, cross*, downArrow*, hook*: Pattern;
		grey0*, grey1*, grey2*, ticks*, solid*: Pattern;

		Broadcast*: MsgProc;

		Pat: List;

		clipx, clipy, clipright, cliptop, height, width: INTEGER;	(* clipping variables *)
		pixctrl1, pixctrl2, copycmd: LONGINT;	
		mask: INTEGER;
		
	PROCEDURE WaitFIFOempty;
	CODE
		MOV DX, 9AE8H
lab1:
		IN AX, DX
		AND AX, 200H
		JNZ lab1
	END WaitFIFOempty;
	
	PROCEDURE EnableRegs;
	VAR i: INTEGER;
	BEGIN
		WaitFIFOempty;
		SYSTEM.PORTOUT(wrtMask, mask);		; (* Write mask *)
		SYSTEM.PORTOUT(rdMask, mask);		; (* Read mask *)
	END EnableRegs;
		
	PROCEDURE max (i, j: INTEGER): INTEGER; BEGIN IF i >= j THEN RETURN i ELSE RETURN j END END max;
	PROCEDURE min (i, j: INTEGER): INTEGER; BEGIN	IF i >= j THEN RETURN j ELSE RETURN i END END min;
		
	PROCEDURE Map*(X: INTEGER): LONGINT;
	BEGIN RETURN 0A0000H	(* Start of the video RAM *)
	END Map;
	
	PROCEDURE AdjustClip*(X, Y, W, H: INTEGER);
	VAR right, top, left, bottom: INTEGER;
	BEGIN 
		right := X + W; top := Y + H; clipx := max(clipx, X); clipy := max(clipy, Y); 
		clipright := min(right, clipright); cliptop := min(top, cliptop);
		top := height-1-cliptop; left := clipx; bottom := height-1-clipy; right := clipright-1;
		IF top < 0 THEN top := 0 ELSIF top > height-1 THEN top := height-1 END;
		IF left < 0 THEN left := 0 ELSIF left > width THEN left := width END;
		IF bottom < 0 THEN bottom := 0 ELSIF bottom > height-1 THEN bottom := height-1 END;
		IF right < 0 THEN right := 0 ELSIF right > width THEN right := width END;
		WaitFIFOempty;
		SYSTEM.PORTOUT(MFcont, 1000H + top);	(* top *)
		SYSTEM.PORTOUT(MFcont, 2000H + left); 			 (* left *)
		SYSTEM.PORTOUT(MFcont, 3000H + bottom);	(* bottom *)
		SYSTEM.PORTOUT(MFcont, 4000H + right); 		 (* right *)
	END AdjustClip;

	PROCEDURE GetDim*(pat: Pattern; VAR w, h: INTEGER);
	VAR s: SHORTINT;
	BEGIN SYSTEM.GET(pat, s); w := s; SYSTEM.GET(pat+1, s); h := s; 
	END GetDim;

	PROCEDURE ResetClip*;
	BEGIN 
		clipx := 0; clipy := UBottom; 
		clipright := width;
		cliptop := height-1;
		WaitFIFOempty;
		SYSTEM.PORTOUT(MFcont, 1000H);	(* top *)
		SYSTEM.PORTOUT(MFcont, 2000H);	(* left *)
		SYSTEM.PORTOUT(MFcont, 3000H + height-1-UBottom);	(* bottom *)
		SYSTEM.PORTOUT(MFcont, 4000H + width-1);	(* right *)
	END ResetClip;
	
	PROCEDURE SetClip*(x, y, w, h: INTEGER);
	VAR right, top, left, bottom: INTEGER;
	BEGIN	
		clipright := x+w;
		cliptop := y+h;
		clipy := y; clipx := x;
		top := height-1-cliptop; left := clipx; bottom := height-1-clipy; right := clipright-1;
		WaitFIFOempty;
		SYSTEM.PORTOUT(MFcont, 1000H + top);	(* top *)
		SYSTEM.PORTOUT(MFcont, 2000H + left); 			 (* left *)
		SYSTEM.PORTOUT(MFcont, 3000H + bottom);	(* bottom *)
		SYSTEM.PORTOUT(MFcont, 4000H + right); 		 (* right *)
	END SetClip;
	
	PROCEDURE GetClip*(VAR x, y, w, h: INTEGER);
	BEGIN 
		x := clipx; y := clipy; w := clipright - clipx; h := cliptop - clipy
	END GetClip;

	PROCEDURE SetColor*(col, red, green, blue: INTEGER);	(* 0 <= col, red, green, blue < 256 *)
	BEGIN
		red := (red + 4) DIV 4 -1;
		green := (green + 4) DIV 4 -1;
		blue := (blue + 4) DIV 4 -1;
		SYSTEM.PORTOUT(3C8H, SHORT(col));
		SYSTEM.PORTOUT(3C9H, SHORT(red));
		SYSTEM.PORTOUT(3C9H, SHORT(green));
		SYSTEM.PORTOUT(3C9H, SHORT(blue))
	END SetColor;

	PROCEDURE GetColor*(col: INTEGER; VAR red, green, blue: INTEGER);
	VAR help: CHAR;
	BEGIN
		SYSTEM.PORTOUT(3C7H, SHORT(col));
		SYSTEM.PORTIN(3C9H, help); red := ORD(help);
		SYSTEM.PORTIN(3C9H, help); green := ORD(help);
		SYSTEM.PORTIN(3C9H, help); blue := ORD(help);
		red := red * 4 + red DIV 16;
		green := green * 4 + green DIV 16;
		blue := blue * 4 + blue DIV 16
	 END GetColor;
	
	PROCEDURE Dot*(col, x, y, mode: INTEGER);
	BEGIN
		y := Height-1-y; 
		WaitFIFOempty;
		IF mode = invert THEN SYSTEM.PORTOUT(FGmix, LONG(25H)) ELSE SYSTEM.PORTOUT(FGmix, LONG(27H)) END;
		SYSTEM.PORTOUT(FGcol, col);
		SYSTEM.PORTOUT(MFcont, SHORT(pixctrl1));
		SYSTEM.PORTOUT(curX, x);
		SYSTEM.PORTOUT(curY, y);
		SYSTEM.PORTOUT(cmdReg, 121BH);
		SYSTEM.PORTOUT(shortStroke, LONG(10H));
	END Dot;

	PROCEDURE CopyBlock*(SX, SY, W, H, DX, DY, mode: INTEGER);
	VAR xpos, ypos: INTEGER;
	BEGIN
		IF (W > 0) & (H > 0) THEN 
			xpos := 0; ypos := 0; 
			IF SY < DY THEN INC(SY, H-1); INC(DY, H-1); ypos := 128 END;
			IF SX < DX THEN INC(SX, W-1); INC(DX, W-1) ELSE xpos := 32 END;
			SY := Height -1- SY; DY := Height -1- DY;
			DEC(W); DEC(H); 
			WaitFIFOempty;
			IF mode = invert THEN SYSTEM.PORTOUT(FGmix, LONG(65H)) ELSE SYSTEM.PORTOUT(FGmix, LONG(67H)) END;
			SYSTEM.PORTOUT(MFcont, SHORT(pixctrl1));
			SYSTEM.PORTOUT(curX, SX);
			SYSTEM.PORTOUT(curY, SY);
			SYSTEM.PORTOUT(diaStep, DX);
			SYSTEM.PORTOUT(axStep, DY);
			SYSTEM.PORTOUT(majAxis, W);
			SYSTEM.PORTOUT(MFcont, H);
			SYSTEM.PORTOUT(cmdReg, SHORT(copycmd) + xpos + ypos);
		END;
	END CopyBlock;

	PROCEDURE SetMode*(X: INTEGER; s: SET);
	BEGIN END SetMode;
	
	PROCEDURE CopyPattern*(col: INTEGER; pat: LONGINT; X, Y, mode: INTEGER);
	VAR width, height: SHORTINT; 
			bit16, h, y: INTEGER; 
			bit8: CHAR; bit24, bit32: SET;
			stride, p: LONGINT;
	BEGIN
		SYSTEM.GET(pat, width);
		SYSTEM.GET(pat+1, height);
		INC(pat, 2);
		WaitFIFOempty; 
		IF mode = invert THEN SYSTEM.PORTOUT(FGmix, LONG(25H)); SYSTEM.PORTOUT(BGmix, LONG(3H)) 
		ELSIF mode = paint THEN SYSTEM.PORTOUT(FGmix, LONG(27H)); SYSTEM.PORTOUT(BGmix, LONG(3H))
		ELSE SYSTEM.PORTOUT(FGmix, LONG(27H)); SYSTEM.PORTOUT(BGmix, LONG(1H)) END;
		SYSTEM.PORTOUT(FGcol, col);
		SYSTEM.PORTOUT(MFcont, SHORT(pixctrl2));
		Y := Height-1-Y;
		stride := ASH(width+7, -3);	(* eos1 *)
		width := SHORT(SHORT(ASH(stride, 3)));
		WHILE width > 32 DO
			INC(X, 31);
			h := height; y := Y; p := pat;
			WHILE h > 0 DO
				SYSTEM.PORTOUT(majAxis, 31);
				SYSTEM.PORTOUT(curX, X);
				SYSTEM.PORTOUT(curY, y);
				SYSTEM.PORTOUT(cmdReg, 239BH);
				SYSTEM.GET(p, bit32);
				bit32 := SYSTEM.ROT(bit32, 16);
				SYSTEM.PORTOUT(pixTrans, SYSTEM.VAL(LONGINT, bit32));
				INC(p, stride); DEC(y); DEC(h)
			END;
			DEC(width, 32); INC(pat, 4); INC(X)
		END;
		INC(X, LONG(width-1));
		SYSTEM.PORTOUT(majAxis, LONG(width)-1);
		IF width <= 8 THEN
			WHILE height > 0 DO DEC(height);
				SYSTEM.GET(pat, bit8); INC(pat, stride);
				SYSTEM.PORTOUT(curX, X);
				SYSTEM.PORTOUT(curY, Y);
				SYSTEM.PORTOUT(cmdReg, 219BH);
				SYSTEM.PORTOUT(pixTrans, ORD(bit8));
				DEC(Y);
			END
		ELSIF width <= 16 THEN
			WHILE height > 0 DO DEC(height);
				SYSTEM.GET(pat, bit16); INC(pat, stride);
				SYSTEM.PORTOUT(curX, X);
				SYSTEM.PORTOUT(curY, Y);
				SYSTEM.PORTOUT(cmdReg, 239BH);
				SYSTEM.PORTOUT(pixTrans, bit16);
				DEC(Y);
			END
		ELSIF width <=24 THEN
			WHILE height > 0 DO DEC(height);
				SYSTEM.GET(pat, bit24); INC(pat, stride);
				bit24 := SYSTEM.LSH(bit24 * {0 .. 23}, 8);
				bit24 := SYSTEM.ROT(bit24, 16);
				SYSTEM.PORTOUT(curX, X);
				SYSTEM.PORTOUT(curY, Y);
				SYSTEM.PORTOUT(cmdReg, 239BH);
				SYSTEM.PORTOUT(pixTrans, SYSTEM.VAL(LONGINT, bit24));
				DEC(Y);
			END
		ELSE
			WHILE height > 0 DO DEC(height);
				SYSTEM.GET(pat, bit32); INC(pat, stride);
				bit32 := SYSTEM.ROT(bit32, 16);
				SYSTEM.PORTOUT(curX, X);
				SYSTEM.PORTOUT(curY, Y);
				SYSTEM.PORTOUT(cmdReg, 239BH);
				SYSTEM.PORTOUT(pixTrans, SYSTEM.VAL(LONGINT, bit32));
				DEC(Y);
			END
		END;
	END CopyPattern;

	PROCEDURE ReplConst*(col, X, Y, W, H, mode: INTEGER);
	BEGIN
		IF (W > 0) & (H > 0) THEN 
			DEC(H); DEC(W); Y := Height-1-Y; 
			WaitFIFOempty;
			IF mode = invert THEN SYSTEM.PORTOUT(FGmix, LONG(25H)) ELSE SYSTEM.PORTOUT(FGmix, LONG(27H)) END;
			SYSTEM.PORTOUT(FGcol, col);
			SYSTEM.PORTOUT(MFcont, SHORT(pixctrl1));
			SYSTEM.PORTOUT(curX, X);
			SYSTEM.PORTOUT(curY, Y);
			SYSTEM.PORTOUT(majAxis, W);
			SYSTEM.PORTOUT(minAxis, H);
			SYSTEM.PORTOUT(cmdReg, 4073H);
		END
	END ReplConst;

	PROCEDURE FillPattern*(col: INTEGER; pat: Pattern; pX, pY, X, Y, W, H, mode: INTEGER);
		VAR patwidth, patheight: SHORTINT; 
			diastep, axstep, errterm, bit16: INTEGER; 
			offset, W0, Y0, X0: INTEGER; 
			pat0, bit32: LONGINT;
			wth, hgt: INTEGER;
	BEGIN 
		IF (W > 0) & (H > 0) THEN 
			SYSTEM.GET(pat, patwidth);
			SYSTEM.GET(pat+1, patheight);
			INC(pat, 2);
			wth := (W+7) DIV 8 * 8;	(* nof complete bytes *)
			axstep := 0;
			diastep := -2*wth;
			errterm := -wth-1;
			INC(X, W-1); 
			Y0 := Y; X0 := X; Y := Height-1-Y;
			WaitFIFOempty;
			IF mode = invert THEN SYSTEM.PORTOUT(FGmix, LONG(25H)); SYSTEM.PORTOUT(BGmix, LONG(3H)) 
			ELSIF mode = paint THEN SYSTEM.PORTOUT(FGmix, LONG(27H)); SYSTEM.PORTOUT(BGmix, LONG(3H))
			ELSE SYSTEM.PORTOUT(FGmix, LONG(27H)); SYSTEM.PORTOUT(BGmix, LONG(1H)) END;
			SYSTEM.PORTOUT(FGcol, col);
			SYSTEM.PORTOUT(MFcont, SHORT(pixctrl2));
			SYSTEM.PORTOUT(majAxis, W-1);
			SYSTEM.PORTOUT(diaStep, diastep);
			SYSTEM.PORTOUT(axStep, axstep);
			SYSTEM.PORTOUT(errTerm, errterm);
			pat0 := pat; W0 := W;
			hgt := patheight - (Y0 + pY) MOD patheight;
			offset := (Y0 + pY) MOD patheight;
			IF patwidth = 16 THEN
				pat := pat + 2*offset;
				WHILE H > 0 DO 
					W := (W + 7) DIV 8 * 4;
					SYSTEM.GET(pat, bit16); INC(pat, 2);
					bit16 := SYSTEM.ROT(bit16, pX-X0);
					SYSTEM.PORTOUT(curX, X);
					SYSTEM.PORTOUT(curY, Y);
					SYSTEM.PORTOUT(cmdReg, 2313H);
					WHILE W > 0 DO
						SYSTEM.PORTOUT(pixTrans, bit16);
						DEC(W,2);
					END;
					DEC(Y);
					DEC(H); DEC(hgt); W := W0;
					IF hgt <= 0 THEN hgt := patheight; pat := pat0 END;
				END
			ELSIF patwidth = 32 THEN
				pat := pat + 4*offset;
				WHILE H > 0 DO 
					W := (W + 7) DIV 8 * 2;
					SYSTEM.GET(pat, bit32); INC(pat, 4);
					bit32 := SYSTEM.ROT(bit32, pX-X0+16);
					SYSTEM.PORTOUT(curX, X);
					SYSTEM.PORTOUT(curY, Y);
					SYSTEM.PORTOUT(cmdReg, 2313H);
					WHILE W > 0 DO
						SYSTEM.PORTOUT(pixTrans, bit32);
						DEC(W,4);
					END;
					DEC(Y);
					DEC(H); DEC(hgt); W := W0;
					IF hgt <= 0 THEN hgt := patheight; pat := pat0 END;
				END
			END;
		END
	END FillPattern;
	
	PROCEDURE ReplPattern*(col: INTEGER; pat: Pattern; X, Y, W, H, mode: INTEGER);
	BEGIN FillPattern(col, pat, 0, 0, X, Y, W, H, mode)
	END ReplPattern;

	PROCEDURE NewPattern*(width, height: INTEGER; VAR image: ARRAY OF SET): Pattern;
	VAR len, src, dest: LONGINT; i: INTEGER; p: PatternPtr; inter: SET;  pl: List;
	BEGIN 
		len := (width+7) DIV 8;
		SYSTEM.NEW(p, 4+len*height); p.w := SHORT(width); p.h := SHORT(height);
		src := SYSTEM.ADR(image); dest := SYSTEM.ADR(p.pixmap);
		i := 0;
		WHILE i < height DO SYSTEM.MOVE(src, dest, len); INC(src, 4); INC(dest, len); INC(i) END;
		NEW(pl);  pl.pat := p;  pl.next := Pat;  Pat := pl;	(* put in list to avoid GC *)
		RETURN SYSTEM.ADR(p.w)
	END NewPattern;
	
	PROCEDURE CreatePatterns;
	VAR image: ARRAY 16 OF SET;
	BEGIN
		image[0] := {13};
		image[1] := {12..14};
		image[2] := {11..13};
		image[3] := {10..12};
		image[4] := {9..11};
		image[5] := {8..10};
		image[6] := {7..9};
		image[7] := {0, 6..8};
		image[8] := {0, 1, 5..7};
		image[9] := {0..2, 4..6};
		image[10] := {0..5};
		image[11] := {0..4};
		image[12] := {0..5};
		image[13] := {0..6};
		image[14] := {0..7};
		arrow := NewPattern(15, 15, image);
		
		image[0] := {0, 10};
		image[1] := {1, 9};
		image[2] := {2, 8};
		image[3] := {3, 7};
		image[4] := {4, 6};
		image[5] := {};
		image[6] := {4, 6};
		image[7] := {3, 7};
		image[8] := {2, 8};
		image[9] := {1, 9};
		image[10] := {0, 10};
		cross := NewPattern(11, 11, image); 
		
		image[0] := {6};
		image[1] := {5..7};
		image[2] := {4..8};
		image[3] := {3..9};
		image[4] := {2..10};
		image[5] := {5..7};
		image[6] := {5..7};
		image[7] := {5..7};
		image[8] := {5..7};
		image[9] := {5..7};
		image[10] := {5..7};
		image[11] := {5..7};
		image[12] := {5..7};
		image[13] := {5..7};
		image[14] := {};
		downArrow := NewPattern(15, 15, image);
		
		image[0] := {0, 4, 8, 12};
		image[1] := {};
		image[2] := {2, 6, 10, 14};
		image[3] := {};
		image[4] := {0, 4, 8, 12};
		image[5] := {};
		image[6] := {2, 6, 10, 14};
		image[7] := {};
		image[8] := {0, 4, 8, 12};
		image[9] := {};
		image[10] := {2, 6, 10, 14};
		image[11] := {};
		image[12] := {0, 4, 8, 12};
		image[13] := {};
		image[14] := {2, 6, 10, 14};
		image[15] := {};
		grey0 := NewPattern(16, 16, image);
		
		image[0] := {0, 2, 4, 6, 8, 10, 12, 14};
		image[1] := {1, 3, 5, 7, 9, 11, 13, 15};
		image[2] := {0, 2, 4, 6, 8, 10, 12, 14};
		image[3] := {1, 3, 5, 7, 9, 11, 13, 15};
		image[4] := {0, 2, 4, 6, 8, 10, 12, 14};
		image[5] := {1, 3, 5, 7, 9, 11, 13, 15};
		image[6] := {0, 2, 4, 6, 8, 10, 12, 14};
		image[7] := {1, 3, 5, 7, 9, 11, 13, 15};
		image[8] := {0, 2, 4, 6, 8, 10, 12, 14};
		image[9] := {1, 3, 5, 7, 9, 11, 13, 15};
		image[10] := {0, 2, 4, 6, 8, 10, 12, 14};
		image[11] := {1, 3, 5, 7, 9, 11, 13, 15};
		image[12] := {0, 2, 4, 6, 8, 10, 12, 14};
		image[13] := {1, 3, 5, 7, 9, 11, 13, 15};
		image[14] := {0, 2, 4, 6, 8, 10, 12, 14};
		image[15] := {1, 3, 5, 7, 9, 11, 13, 15};
		grey1 := NewPattern(16, 16, image);
		
		image[0] := {0, 1, 4, 5, 8, 9, 12, 13};
		image[1] := {0, 1, 4, 5, 8, 9, 12, 13};
		image[2] := {2, 3, 6, 7, 10, 11, 14, 15};
		image[3] := {2, 3, 6, 7, 10, 11, 14, 15};
		image[4] := {0, 1, 4, 5, 8, 9, 12, 13};
		image[5] := {0, 1, 4, 5, 8, 9, 12, 13};
		image[6] := {2, 3, 6, 7, 10, 11, 14, 15};
		image[7] := {2, 3, 6, 7, 10, 11, 14, 15};
		image[8] := {0, 1, 4, 5, 8, 9, 12, 13};
		image[9] := {0, 1, 4, 5, 8, 9, 12, 13};
		image[10] := {2, 3, 6, 7, 10, 11, 14, 15};
		image[11] := {2, 3, 6, 7, 10, 11, 14, 15};
		image[12] := {0, 1, 4, 5, 8, 9, 12, 13};
		image[13] := {0, 1, 4, 5, 8, 9, 12, 13};
		image[14] := {2, 3, 6, 7, 10, 11, 14, 15};
		image[15] := {2, 3, 6, 7, 10, 11, 14, 15};
		grey2 := NewPattern(16, 16, image);
		
		image[0] := {0..2, 8..11};
		image[1] := {0..2, 7..10};
		image[2] := {0..2, 6..9};
		image[3] := {0..2, 5..8};
		image[4] := {0..2, 4..7};
		image[5] := {0..6};
		image[6] := {0..5};
		image[7] := {0..4};
		image[8] := {0..3};
		image[9] := {0..2};
		image[10] := {0, 1};
		image[11] := {0};
		hook := NewPattern(12, 12, image);
		
		image[0] := {7};
		image[1] := {7};
		image[2] := {2, 7, 12};
		image[3] := {3, 7, 11};
		image[4] := {4, 7, 10};
		image[5] := {5, 7, 9};
		image[6] := {6..8};
		image[7] := {0..6, 8..14};
		image[8] := {6..8};
		image[9] := {5, 7, 9};
		image[10] := {4, 7, 10};
		image[11] := {3, 7, 11};
		image[12] := {2, 7, 12};
		image[13] := {7};
		image[14] := {7};
		star := NewPattern(15, 15, image);
		
		image[0] := {};
		image[1] := {};
		image[2] := {0};
		image[3] := {};
		image[4] := {};
		image[5] := {};
		image[6] := {};
		image[7] := {};
		image[8] := {};
		image[9] := {};
		image[10] := {};
		image[11] := {};
		image[12] := {};
		image[13] := {};
		image[14] := {};
		image[15] := {};
		ticks := NewPattern(16, 16, image);
		
		image[0] := -{};
		image[1] := -{};
		solid := NewPattern(16, 2, image);
		
	END CreatePatterns;
	
	PROCEDURE Depth*(X: INTEGER): INTEGER;
	BEGIN RETURN 8 END Depth;
	
	PROCEDURE DisplayBlock*(B:LONGINT; DX, DY, W, H, SX, SY, mode:INTEGER);
	VAR BitmapWth, locW, locH: LONGINT;
	CODE
		MOVSX EAX, Width
		MOV locW[EBP], EAX	; locW := Width
		
		MOVSX EAX, Height
		DEC EAX
		DEC EAX
		MOV locH[EBP], EAX	; locH := Height-2
		
		MOVSX EAX, SY[EBP]
		MOV DWORD SY[EBP], EAX
		
		MOV ESI, B[EBP]    		; address of bitmap descriptor
		MOV EDI, 12[ESI]
		MOV ESI, 8[ESI] 
		MOV BitmapWth[EBP], ESI
		MOVZX ECX, DY[EBP]
		IMUL ESI,ECX
		MOVZX EBX, WORD 32[EBP]	; DX
		ADD ESI, EBX	
		ADD ESI, EDI				; esi = source index register
		MOV EDI, locW[EBP]
		MOV EBX, locH[EBP]
		DEC EBX										;!!!!
		SUB EBX,DWORD SY[EBP]
		IMUL EDI,EBX 
		MOVZX EBX, SX[EBP]
		ADD EDI, EBX				; edi = destination index register without VGAaddr
		MOV EAX, locH[EBP]
		SUB AX, SY[EBP]
		MOV SY[EBP], AX
		
		MOV DX, 9AE8H
lab1:
		IN AX, DX
		AND AX, 100H
		JNZ lab1
		
		CMP mode[EBP], 1
		JL repllab
		JG invlab
		MOV AX, 4BH
		JMP contlab
repllab:
		MOV AX, 47H
		JMP contlab
invlab:
		MOV AX, 45H
contlab:
		MOV DX, 0BAE8H
		OUT DX, AX
		
		MOV DX, 0BEE8H
		MOV AX, 0A000H
		OUT DX, AX
		
		MOV DX, 086E8H
		MOV AX, SX[EBP]
		OUT DX, AX
		MOV DX, 082E8H
		MOV AX, SY[EBP]
		OUT DX, AX
		
		MOV DX, 096E8H
		MOV AX, W[EBP]
		DEC AX
		OUT DX, AX
		
		MOV DX, 0BEE8H
		MOV AX, H[EBP]
		DEC AX
		OUT DX, AX
		
		MOV DX, 09AE8H
		MOV AX, 05331H
		OUT DX, AX
		
		MOV DX, 0E2E8H
		
RowLoopR:
		MOV CX, W[EBP]
		INC CX
		SHR CX, 1
		PUSH ESI
lab2:
		MOV AX, [ESI]
		OUT DX, AX
		INC ESI
		INC ESI
		DEC CX
		JNZ lab2
		POP ESI
		ADD ESI, BitmapWth[EBP]
		DEC H[EBP]
		JNZ RowLoopR
DispEnd:
	END DisplayBlock;
	
BEGIN
	Width := 1024;
	Height := 768;
	Left:= 0; ColLeft:= 0; Bottom:= 0; UBottom:= -256; 
	Pat := NIL;
	mask := -1; pixctrl1 := 0A000H; pixctrl2 := 0A080H; copycmd := 0C053H;
	EnableRegs;
	width := Width;
	height := Height;
	ResetClip;
	CreatePatterns;
	Unit := 10000
END Display.
